<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
<title>12 Janggi</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700;900&family=Crimson+Pro:ital,wght@0,300;0,400;1,300&display=swap');

  :root {
    --red-bg: #d45a5a;
    --blue-bg: #5a8fd4;
    --brown-bg: #c49a6c;
    --cell-size: 100px;
    --grid-line: 2px;
    --grid-color: rgba(0,0,0,0.22);
  }

  * { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    min-height: 100dvh;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: #1a1410;
    background-image:
      radial-gradient(ellipse at 20% 50%, rgba(80,40,20,0.4) 0%, transparent 55%),
      radial-gradient(ellipse at 80% 50%, rgba(40,60,90,0.35) 0%, transparent 55%);
    font-family: 'Crimson Pro', serif;
    color: #e8ddd0;
    overflow-x: hidden;
    -webkit-tap-highlight-color: transparent;
    user-select: none;
    padding: 12px 6px;
  }

  /* â”€â”€ HEADER â”€â”€ */
  .header { text-align: center; margin-bottom: 14px; }
  .header h1 {
    font-family: 'Cinzel', serif;
    font-size: 2.4rem;
    font-weight: 900;
    letter-spacing: 0.08em;
    color: #f0e6d3;
    text-shadow: 0 2px 12px rgba(0,0,0,0.6);
  }
  .header h1::before, .header h1::after {
    content: 'â”€'; color: #c49a6c; margin: 0 10px;
    font-size: 1.1rem; vertical-align: middle;
  }
  .header .subtitle {
    font-style: italic; font-weight: 300;
    color: #a09080; font-size: 0.9rem;
    margin-top: 2px; letter-spacing: 0.12em;
  }

  /* â”€â”€ CONTROLS â”€â”€ */
  .controls {
    display: flex; gap: 8px; align-items: center;
    margin-bottom: 10px; flex-wrap: wrap; justify-content: center;
  }
  .controls select, .controls button {
    font-family: 'Cinzel', serif; font-size: 0.75rem;
    letter-spacing: 0.06em; padding: 6px 12px;
    border-radius: 4px; border: 1px solid #5a4e3c;
    background: #2a2420; color: #d4c4a8;
    cursor: pointer; transition: background 0.2s, border-color 0.2s;
  }
  .controls select:hover, .controls button:hover {
    background: #3a3028; border-color: #8a7a5c;
  }
  .controls button.btn-start {
    background: linear-gradient(135deg, #7a5a2e, #5a3e1e);
    border-color: #9a7a4c; color: #f0dcc0; font-weight: 700;
  }
  .controls button.btn-start:hover {
    background: linear-gradient(135deg, #8a6a3e, #6a4e2e);
  }
  .controls label { font-size: 0.78rem; color: #8a7a60; letter-spacing: 0.04em; }

  /* â”€â”€ STATUS â”€â”€ */
  .status-bar {
    min-height: 26px; margin-bottom: 8px;
    display: flex; align-items: center; justify-content: center; gap: 16px;
  }
  .status-turn {
    font-family: 'Cinzel', serif; font-size: 0.84rem;
    letter-spacing: 0.1em; color: #c4b48a;
  }
  .status-turn .dot {
    display: inline-block; width: 10px; height: 10px;
    border-radius: 50%; margin-right: 5px; vertical-align: middle;
    border: 2px solid rgba(255,255,255,0.25);
  }
  .status-turn .dot.black { background: #1a1a1a; }
  .status-turn .dot.white { background: #eeeeee; }
  .status-msg { font-size: 0.78rem; color: #9a8a6a; font-style: italic; }

  /* â”€â”€ ARENA (board + trays row) â”€â”€ */
  .arena {
    display: flex;
    align-items: stretch;
    gap: 10px;
    justify-content: center;
  }

  /* â”€â”€ CAPTURE TRAY â”€â”€ */
  .tray {
    width: 72px;
    background: #2a2218;
    border: 1px solid #4a3e2e;
    border-radius: 6px;
    padding: 8px 5px;
    display: flex;
    flex-direction: column;
    gap: 5px;
    align-items: center;
  }
  .tray-label {
    font-family: 'Cinzel', serif;
    font-size: 0.58rem;
    letter-spacing: 0.1em;
    color: #7a6a4a;
    text-transform: uppercase;
    margin-bottom: 2px;
    text-align: center;
    line-height: 1.3;
  }
  .tray-label .tray-dot {
    display: inline-block; width: 7px; height: 7px;
    border-radius: 50%; vertical-align: middle; margin-right: 2px;
  }
  .tray-label .tray-dot.black { background: #1a1a1a; border: 1px solid #555; }
  .tray-label .tray-dot.white { background: #eee; border: 1px solid #999; }

  .tray-piece {
    width: 48px; height: 48px;
    display: flex; align-items: center; justify-content: center;
    cursor: pointer;
    transition: transform 0.13s;
    flex-shrink: 0;
  }
  .tray-piece:hover { transform: scale(1.1); }
  .tray-piece .lbl {
    font-family: 'Cinzel', serif; font-weight: 700;
    font-size: 0.8rem; letter-spacing: 0.02em;
    color: #1a1a1a;
  }
  .tray-piece.selected-tray img {
    filter: drop-shadow(0 0 5px rgba(255,220,100,0.95)) drop-shadow(0 0 10px rgba(255,220,100,0.6));
    transform: scale(1.08);
  }
  /* PNG image inside tray piece */
  .tray-piece img { width: 40px; height: 40px; object-fit: contain; }

  /* â”€â”€ BOARD WRAPPER â”€â”€ */
  .board-wrap {
    position: relative;
    background: #3b2e1e;
    border-radius: 6px;
    padding: 8px;
    box-shadow:
      0 0 0 3px #5a4530,
      0 0 0 6px #3a2e1e,
      0 8px 32px rgba(0,0,0,0.6);
  }

  /* â”€â”€ BOARD GRID â”€â”€ */
  .board {
    display: grid;
    grid-template-columns: repeat(3, var(--cell-size));
    grid-template-rows: repeat(4, var(--cell-size));
    border-radius: 3px;
    overflow: hidden;
    /* outer border of entire grid */
    border: var(--grid-line) solid var(--grid-color);
  }

  /* â”€â”€ CELL â”€â”€ */
  .cell {
    width: var(--cell-size);
    height: var(--cell-size);
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: filter 0.15s;
    /* right + bottom gridline; top/left handled by grid border or neighbour */
    border-right: var(--grid-line) solid var(--grid-color);
    border-bottom: var(--grid-line) solid var(--grid-color);
  }
  /* kill double-lines on right edge and bottom edge */
  .cell:nth-child(3n)   { border-right: none; }
  .cell:nth-child(n+10) { border-bottom: none; }   /* last row (cells 10-12) */

  .cell:hover { filter: brightness(1.13); }

  .cell.row-red   { background: var(--red-bg); }
  .cell.row-brown { background: var(--brown-bg); }
  .cell.row-blue  { background: var(--blue-bg); }

  /* â”€â”€ CELL HIGHLIGHTS â”€â”€ */
  .cell.selected {
    box-shadow: inset 0 0 0 4px rgba(255,220,100,0.85);
    z-index: 2;
  }
  .cell.valid-move::after {
    content: ''; position: absolute;
    width: 26px; height: 26px; border-radius: 50%;
    background: rgba(255,230,80,0.45);
    border: 2px solid rgba(255,210,50,0.7);
    z-index: 1; pointer-events: none;
  }
  .cell.valid-capture::after {
    content: ''; position: absolute;
    width: 100%; height: 100%;
    background: rgba(200,40,40,0.3);
    border: 3px solid rgba(220,60,60,0.7);
    z-index: 1; pointer-events: none;
  }
  /* placement highlight (from tray) â€” softer green */
  .cell.valid-place::after {
    content: ''; position: absolute;
    width: 26px; height: 26px; border-radius: 50%;
    background: rgba(80,210,120,0.4);
    border: 2px solid rgba(100,230,140,0.7);
    z-index: 1; pointer-events: none;
  }

  /* â”€â”€ PIECE (on board) â”€â”€ */
  .piece {
    position: relative; z-index: 3;
    width: 78px; height: 78px;
    display: flex; align-items: center; justify-content: center;
    transition: transform 0.15s;
    cursor: grab;
  }
  .piece:active { transform: scale(0.92); }
  .piece .lbl {
    font-family: 'Cinzel', serif; font-weight: 700;
    font-size: 1.3rem; letter-spacing: 0.02em;
    color: #1a1a1a;
  }
  /* PNG image inside board piece */
  .piece img { width: 68px; height: 68px; object-fit: contain; }

  /* â”€â”€ KING ADVANCE GLOW â”€â”€ */
  .piece.king-advance img {
    filter: drop-shadow(0 0 8px rgba(255,200,50,0.85)) drop-shadow(0 0 14px rgba(255,200,50,0.5));
    animation: kingPulse 1s ease-in-out infinite alternate;
  }
  @keyframes kingPulse {
    from { filter: drop-shadow(0 0 8px rgba(255,200,50,0.85)) drop-shadow(0 0 14px rgba(255,200,50,0.5)); }
    to   { filter: drop-shadow(0 0 14px rgba(255,210,80,1))   drop-shadow(0 0 24px rgba(255,210,80,0.6)); }
  }

  /* â”€â”€ OVERLAY â”€â”€ */
  .overlay {
    position: fixed; inset: 0;
    background: rgba(15,10,5,0.82);
    display: flex; align-items: center; justify-content: center;
    z-index: 100; backdrop-filter: blur(3px);
  }
  .overlay.hidden { display: none; }
  .overlay-box {
    background: linear-gradient(160deg, #2a2018, #1e1812);
    border: 1px solid #5a4830; border-radius: 10px;
    padding: 34px 40px; text-align: center;
    max-width: 340px; width: 90%;
    box-shadow: 0 12px 48px rgba(0,0,0,0.7);
  }
  .overlay-box h2 {
    font-family: 'Cinzel', serif; font-size: 1.5rem;
    color: #f0dcc0; margin-bottom: 6px; letter-spacing: 0.06em;
  }
  .overlay-box .result-icon { font-size: 2.6rem; margin-bottom: 4px; }
  .overlay-box p {
    color: #9a8a6a; font-size: 0.88rem;
    margin-bottom: 18px; line-height: 1.5;
  }
  .overlay-box button {
    font-family: 'Cinzel', serif; font-size: 0.8rem;
    letter-spacing: 0.1em; padding: 8px 26px;
    background: linear-gradient(135deg, #7a5a2e, #5a3e1e);
    border: 1px solid #9a7a4c; color: #f0dcc0;
    border-radius: 4px; cursor: pointer; transition: background 0.2s;
  }
  .overlay-box button:hover { background: linear-gradient(135deg, #8a6a3e, #6a4e2e); }

  /* â”€â”€ RESPONSIVE â”€â”€ */
  /* stack trays above/below on narrow screens */
  @media (max-width: 440px) {
    .arena { flex-direction: column; align-items: center; gap: 6px; }
    .tray {
      flex-direction: row; width: auto;
      padding: 5px 8px; gap: 4px;
      align-items: center;
    }
    .tray-label { margin-bottom: 0; margin-right: 4px; white-space: nowrap; }
    .tray-piece { width: 38px; height: 38px; }
    .tray-piece img { width: 32px; height: 32px; }
    /* swap order: black tray top, white tray bottom */
    .tray.tray-black { order: -1; }
    .tray.tray-white { order: 1; }
  }
  @media (max-width: 380px) {
    :root { --cell-size: 82px; }
    .header h1 { font-size: 1.9rem; }
    .piece { width: 64px; height: 64px; }
    .piece .lbl { font-size: 1.1rem; }
    .piece img { width: 56px; height: 56px; }
  }
  @media (max-width: 320px) {
    :root { --cell-size: 74px; }
    .piece { width: 58px; height: 58px; }
    .piece img { width: 50px; height: 50px; }
  }
</style>
</head>
<body>

<!-- HEADER -->
<div class="header">
  <h1>12 Janggi</h1>
  <div class="subtitle">A game of kings &amp; conquest</div>
</div>

<!-- CONTROLS -->
<div class="controls">
  <label>Play as</label>
  <select id="colorSelect">
    <option value="white">White (bottom)</option>
    <option value="black">Black (top)</option>
  </select>
  <label>vs</label>
  <select id="opponentSelect">
    <option value="cpu">CPU</option>
    <option value="human">Friend (local)</option>
  </select>
  <button class="btn-start" id="btnStart">New Game</button>
</div>

<!-- STATUS -->
<div class="status-bar">
  <div class="status-turn" id="statusTurn">
    <span class="dot white"></span> White's turn
  </div>
  <div class="status-msg" id="statusMsg">Press New Game to begin</div>
</div>

<!-- ARENA: trays + board -->
<div class="arena">
  <!-- Black's captured pieces (pieces black has won) -->
  <div class="tray tray-black" id="trayBlack">
    <div class="tray-label"><span class="tray-dot black"></span>Black's<br>captures</div>
  </div>

  <!-- BOARD -->
  <div class="board-wrap">
    <div class="board" id="board"></div>
  </div>

  <!-- White's captured pieces (pieces white has won) -->
  <div class="tray tray-white" id="trayWhite">
    <div class="tray-label"><span class="tray-dot white"></span>White's<br>captures</div>
  </div>
</div>

<!-- GAME-OVER OVERLAY -->
<div class="overlay hidden" id="overlay">
  <div class="overlay-box">
    <div class="result-icon" id="resultIcon">ğŸ‘‘</div>
    <h2 id="resultTitle">Game Over</h2>
    <p id="resultDesc"></p>
    <button id="btnRestart">Play Again</button>
  </div>
</div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  PNG PIECE IMAGES
//  PNGs live in ./assets/ with naming: piecename_color.png
//  e.g.  assets/rook_black.png   assets/queen_white.png
//  TYPE code â†’ filename stem is resolved automatically.
//  Set USE_IMAGES = false to fall back to letter labels.
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const USE_IMAGES = true;

const TYPE_NAME = { R:'rook', K:'king', B:'bishop', P:'pawn', Q:'queen' };

function pieceInnerHTML(type, color) {
  if (USE_IMAGES && TYPE_NAME[type]) {
    const src = 'assets/' + TYPE_NAME[type] + '_' + color + '.png';
    return '<img src="' + src + '" alt="' + color + ' ' + TYPE_NAME[type] + '">';
  }
  return '<span class="lbl">' + type + '</span>';
}

// â”€â”€â”€ CONSTANTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const ROWS = 4, COLS = 3;
const ROW_ZONE = ['row-red','row-brown','row-brown','row-blue'];
const P = { ROOK:'R', KING:'K', BISHOP:'B', PAWN:'P', QUEEN:'Q' };

// Back-rank rows: the "home" row that each color defends
// Black defends row 0 (red).  White defends row 3 (blue).
// A captured piece CANNOT be placed on the opponent's back-rank row:
//   black pieces cannot be placed on row 3 (blue)
//   white pieces cannot be placed on row 0 (red)
const FORBIDDEN_ROW = { black: 3, white: 0 };

// â”€â”€â”€ GAME STATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let board            = [];
let turn             = 'black';
let selected         = null;       // { r, c } â€” board piece selected
let selectedTray     = null;       // { color, type, idx } â€” tray piece selected
let validMoves       = [];         // moves for selected board piece
let gameOver         = false;
let playerColor      = 'white';
let vsMode           = 'cpu';
let kingAdvanceColor = null;

// Capture trays: pieces each side has captured (now belonging to that side)
// blackCaptures = pieces black has taken â†’ black can deploy them
// whiteCaptures = pieces white has taken â†’ white can deploy them
let blackCaptures = [];   // [{ type, color:'black' }, ...]
let whiteCaptures = [];

// â”€â”€â”€ INIT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function initBoard() {
  board = Array.from({ length: ROWS }, () => Array(COLS).fill(null));
  board[0][0] = { type: P.ROOK,   color: 'black' };
  board[0][1] = { type: P.KING,   color: 'black' };
  board[0][2] = { type: P.BISHOP, color: 'black' };
  board[1][1] = { type: P.PAWN,   color: 'black' };
  board[2][1] = { type: P.PAWN,   color: 'white' };
  board[3][0] = { type: P.BISHOP, color: 'white' };
  board[3][1] = { type: P.KING,   color: 'white' };
  board[3][2] = { type: P.ROOK,   color: 'white' };

  turn             = 'white';
  selected         = null;
  selectedTray     = null;
  validMoves       = [];
  gameOver         = false;
  kingAdvanceColor = null;
  blackCaptures    = [];
  whiteCaptures    = [];
}

function startGame() {
  playerColor = document.getElementById('colorSelect').value;
  vsMode      = document.getElementById('opponentSelect').value;
  initBoard();
  hideOverlay();
  render();
  updateStatus();
  if (vsMode === 'cpu' && turn !== playerColor) {
    setTimeout(cpuMove, 420);
  }
}

document.getElementById('btnStart').addEventListener('click', startGame);
document.getElementById('btnRestart').addEventListener('click', startGame);

// â”€â”€â”€ HELPERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function inBounds(r, c) { return r >= 0 && r < ROWS && c >= 0 && c < COLS; }

function getCapturesFor(color) {
  return color === 'black' ? blackCaptures : whiteCaptures;
}

function removeCaptureAt(color, idx) {
  const arr = getCapturesFor(color);
  arr.splice(idx, 1);
}

// â”€â”€â”€ RENDERING â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function render() {
  renderBoard();
  renderTray('black');
  renderTray('white');
}

function renderBoard() {
  const boardEl = document.getElementById('board');
  boardEl.innerHTML = '';
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      const cell = document.createElement('div');
      cell.className = 'cell ' + ROW_ZONE[r];
      cell.dataset.r = r;
      cell.dataset.c = c;

      // Highlight selected board piece
      if (selected && selected.r === r && selected.c === c) {
        cell.classList.add('selected');
      }

      // Highlights when a BOARD piece is selected
      if (selected && !selectedTray) {
        const vm = validMoves.find(m => m.r === r && m.c === c);
        if (vm) cell.classList.add(vm.capture ? 'valid-capture' : 'valid-move');
      }

      // Highlights when a TRAY piece is selected â€” show valid placement cells
      if (selectedTray) {
        if (!board[r][c] && r !== FORBIDDEN_ROW[selectedTray.color]) {
          cell.classList.add('valid-place');
        }
      }

      // Render piece
      const piece = board[r][c];
      if (piece) {
        const pEl = document.createElement('div');
        pEl.className = 'piece ' + piece.color;
        if (piece.type === P.KING && kingAdvanceColor === piece.color) {
          pEl.classList.add('king-advance');
        }
        pEl.innerHTML = pieceInnerHTML(piece.type, piece.color);
        cell.appendChild(pEl);
      }

      cell.addEventListener('click', () => onCellClick(r, c));
      boardEl.appendChild(cell);
    }
  }
}

function renderTray(color) {
  const trayEl  = document.getElementById(color === 'black' ? 'trayBlack' : 'trayWhite');
  const captures = getCapturesFor(color);
  // Keep the label, remove old pieces
  const label = trayEl.querySelector('.tray-label');
  trayEl.innerHTML = '';
  trayEl.appendChild(label);

  captures.forEach((cap, idx) => {
    const pEl = document.createElement('div');
    pEl.className = 'tray-piece ' + cap.color;
    if (selectedTray && selectedTray.color === color && selectedTray.idx === idx) {
      pEl.classList.add('selected-tray');
    }
    pEl.innerHTML = pieceInnerHTML(cap.type, cap.color, 30);
    pEl.addEventListener('click', (e) => {
      e.stopPropagation();
      onTrayClick(color, idx);
    });
    trayEl.appendChild(pEl);
  });
}

// â”€â”€â”€ STATUS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateStatus() {
  const label = document.getElementById('statusTurn');
  label.innerHTML = '<span class="dot ' + turn + '"></span> ' +
    (turn.charAt(0).toUpperCase() + turn.slice(1)) + '\'s turn';

  let msg = '';
  if (kingAdvanceColor) {
    msg = 'ğŸ‘‘ King reached the far end â€” opponent must capture or lose!';
  } else if (selectedTray) {
    msg = 'Tap an empty square to place ' + selectedTray.type + ' (not on opponent\'s back row)';
  }
  document.getElementById('statusMsg').textContent = msg;
}

// â”€â”€â”€ MOVE GENERATION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function getMovesFor(r, c) {
  const piece = board[r][c];
  if (!piece) return [];
  const moves = [];
  const enemy = piece.color === 'black' ? 'white' : 'black';

  let dirs = [];
  switch (piece.type) {
    case P.ROOK:   dirs = [[-1,0],[1,0],[0,-1],[0,1]]; break;
    case P.KING:   dirs = [[-1,0],[1,0],[0,-1],[0,1],[-1,-1],[-1,1],[1,-1],[1,1]]; break;
    case P.BISHOP: dirs = [[-1,-1],[-1,1],[1,-1],[1,1]]; break;                          // diagonals only
    case P.QUEEN:  dirs = [[-1,0],[1,0],[0,-1],[0,1],[-1,-1],[-1,1],[1,-1],[1,1]]; break; // all 8
    case P.PAWN: {
      const fwd = piece.color === 'black' ? 1 : -1;
      const nr = r + fwd, nc = c;
      if (inBounds(nr, nc)) {
        if (!board[nr][nc])                        moves.push({ r: nr, c: nc, capture: false });
        else if (board[nr][nc].color === enemy)    moves.push({ r: nr, c: nc, capture: true  });
      }
      return moves;
    }
  }

  for (const [dr, dc] of dirs) {
    const nr = r + dr, nc = c + dc;
    if (!inBounds(nr, nc)) continue;
    const target = board[nr][nc];
    if (!target)                        moves.push({ r: nr, c: nc, capture: false });
    else if (target.color === enemy)    moves.push({ r: nr, c: nc, capture: true  });
  }
  return moves;
}

// â”€â”€â”€ CLICK HANDLERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function onTrayClick(color, idx) {
  if (gameOver) return;
  if (vsMode === 'cpu' && turn !== playerColor) return;
  // Can only select from own tray on own turn
  if (color !== turn) return;

  // Toggle selection
  if (selectedTray && selectedTray.color === color && selectedTray.idx === idx) {
    selectedTray = null;
  } else {
    selectedTray = { color, type: getCapturesFor(color)[idx].type, idx };
    selected     = null;   // deselect any board piece
    validMoves   = [];
  }
  render();
  updateStatus();
}

function onCellClick(r, c) {
  if (gameOver) return;
  if (vsMode === 'cpu' && turn !== playerColor) return;

  // â”€â”€ If a tray piece is selected â†’ try to PLACE it â”€â”€
  if (selectedTray) {
    // Valid placement: empty cell, not on forbidden row
    if (!board[r][c] && r !== FORBIDDEN_ROW[selectedTray.color]) {
      placeTrayPiece(r, c);
    } else {
      // Clicked an invalid spot â€” deselect tray
      selectedTray = null;
      render();
      updateStatus();
    }
    return;
  }

  const piece = board[r][c];

  // â”€â”€ If a board piece is selected â†’ try to MOVE â”€â”€
  const target = validMoves.find(m => m.r === r && m.c === c);
  if (target && selected) {
    executeMove(selected.r, selected.c, r, c);
    return;
  }

  // â”€â”€ Click own piece â†’ select â”€â”€
  if (piece && piece.color === turn) {
    selected     = { r, c };
    selectedTray = null;
    validMoves   = getMovesFor(r, c);
    render();
    updateStatus();
    return;
  }

  // â”€â”€ Otherwise deselect â”€â”€
  selected     = null;
  selectedTray = null;
  validMoves   = [];
  render();
  updateStatus();
}

// â”€â”€â”€ PLACE FROM TRAY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function placeTrayPiece(r, c) {
  const color = selectedTray.color;
  const type  = selectedTray.type;
  const idx   = selectedTray.idx;

  // Place the piece on the board
  board[r][c] = { type, color };
  // Remove from tray
  removeCaptureAt(color, idx);
  // Clear selection
  selectedTray = null;
  selected     = null;
  validMoves   = [];

  // Check king-advance survival (the placing side just finished their turn)
  if (kingAdvanceColor && kingAdvanceColor !== color) {
    // The advancing king was NOT captured this turn (the turn was a placement) â†’ advancing king wins
    gameOver = true;
    showGameOver(kingAdvanceColor, 'king_advance');
    render();
    return;
  }

  // Switch turn
  turn = (turn === 'black') ? 'white' : 'black';
  render();
  updateStatus();

  if (vsMode === 'cpu' && turn !== playerColor && !gameOver) {
    setTimeout(cpuMove, 380);
  }
}

// â”€â”€â”€ EXECUTE BOARD MOVE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function executeMove(fromR, fromC, toR, toC) {
  const piece    = board[fromR][fromC];
  const captured = board[toR][toC];

  board[toR][toC]     = piece;
  board[fromR][fromC] = null;
  selected            = null;
  selectedTray        = null;
  validMoves          = [];

  // â”€â”€ Win: king captured â”€â”€
  if (captured && captured.type === P.KING) {
    gameOver = true;
    showGameOver(piece.color, 'king_captured');
    render();
    return;
  }

  // â”€â”€ Win: advancing king survived â”€â”€
  if (kingAdvanceColor && kingAdvanceColor !== piece.color) {
    gameOver = true;
    showGameOver(kingAdvanceColor, 'king_advance');
    render();
    return;
  }

  // â”€â”€ Capture: piece changes allegiance, goes to capturer's tray â”€â”€
  if (captured) {
    // Flip color to capturer's color
    const newPiece = { type: captured.type, color: piece.color };
    if (piece.color === 'black') blackCaptures.push(newPiece);
    else                         whiteCaptures.push(newPiece);
  }

  // â”€â”€ Pawn promotion: reaching the far rank promotes to Queen â”€â”€
  if (piece.type === P.PAWN) {
    if ((piece.color === 'white' && toR === 0) ||
        (piece.color === 'black' && toR === 3)) {
      board[toR][toC] = { type: P.QUEEN, color: piece.color };
    }
  }

  // â”€â”€ Check king advance (king reached opponent's back rank) â”€â”€
  kingAdvanceColor = null;
  if (piece.type === P.KING) {
    if (piece.color === 'white' && toR === 0) kingAdvanceColor = 'white';
    if (piece.color === 'black' && toR === 3) kingAdvanceColor = 'black';
  }

  // â”€â”€ Switch turn â”€â”€
  turn = (turn === 'black') ? 'white' : 'black';
  render();
  updateStatus();

  if (vsMode === 'cpu' && turn !== playerColor && !gameOver) {
    setTimeout(cpuMove, 380);
  }
}

// â”€â”€â”€ CPU AI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function cpuMove() {
  if (gameOver) return;
  const cpuColor   = (playerColor === 'white') ? 'black' : 'white';
  const enemyColor = playerColor;

  // â”€â”€ Gather all board moves â”€â”€
  let allMoves = [];
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      const p = board[r][c];
      if (p && p.color === cpuColor) {
        getMovesFor(r, c).forEach(m => {
          allMoves.push({ kind:'board', fromR:r, fromC:c, toR:m.r, toC:m.c, capture:m.capture, piece:p });
        });
      }
    }
  }

  // â”€â”€ Gather all tray placement moves â”€â”€
  const captures = getCapturesFor(cpuColor);
  // De-dup: only one placement move per unique piece type (placing two Rooks is the same strategically)
  const addedTypes = new Set();
  captures.forEach((cap, idx) => {
    if (addedTypes.has(cap.type)) return;
    addedTypes.add(cap.type);
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        if (!board[r][c] && r !== FORBIDDEN_ROW[cpuColor]) {
          allMoves.push({ kind:'place', idx, type:cap.type, color:cpuColor, toR:r, toC:c, capture:false, piece:cap });
        }
      }
    }
  });

  if (allMoves.length === 0) {
    gameOver = true;
    showGameOver(enemyColor, 'stalemate');
    render();
    return;
  }

  // â”€â”€ Piece values â”€â”€
  const PIECE_VALUE = { P:1, B:2, R:3, Q:4, K:100 };

  // Returns true if the enemy can capture the piece sitting at (r,c) on their next move.
  // We temporarily place `testPiece` at (r,c) to simulate; if testPiece is null we just
  // check whatever is already there.
  function canBeAttackedBy(r, c, enemyColor, testPiece) {
    const saved = board[r][c];
    if (testPiece !== undefined) board[r][c] = testPiece;   // simulate
    let threatened = false;
    for (let er = 0; er < ROWS && !threatened; er++) {
      for (let ec = 0; ec < COLS && !threatened; ec++) {
        const ep = board[er][ec];
        if (!ep || ep.color !== enemyColor) continue;
        const eMoves = getMovesFor(er, ec);
        if (eMoves.some(m => m.r === r && m.c === c)) threatened = true;
      }
    }
    board[r][c] = saved;   // restore
    return threatened;
  }

  // â”€â”€ Score every candidate move â”€â”€
  function scoreMove(mv) {
    const target   = board[mv.toR][mv.toC];
    const movingPV = PIECE_VALUE[mv.piece.type] || 0;

    // â•â• TIER 1: instant win or forced defence â•â•
    // Capture the enemy king â†’ game over, pick this immediately
    if (target && target.type === P.KING) return 100000;

    // Enemy king is advancing â€” we MUST capture it or we lose next turn
    if (kingAdvanceColor === enemyColor) {
      if (target && target.type === P.KING) return 90000;
      return -50000;   // any move that doesn't grab it loses
    }

    let score = 0;

    // â•â• TIER 2: capture value + trade safety lookahead â•â•
    if (mv.capture && target) {
      const capturedPV = PIECE_VALUE[target.type] || 0;
      score += capturedPV * 20;   // base reward for the capture

      // After we land on (toR,toC), can the enemy recapture us there?
      // Simulate: temporarily remove our piece from its origin so the
      // enemy's move-gen sees the board as it will actually be.
      const savedFrom = board[mv.fromR][mv.fromC];
      board[mv.fromR][mv.fromC] = null;
      const willBeRecaptured = canBeAttackedBy(mv.toR, mv.toC, enemyColor, mv.piece);
      board[mv.fromR][mv.fromC] = savedFrom;

      if (willBeRecaptured) {
        // Net material = what we gain minus what we lose
        const net = capturedPV - movingPV;
        if (net >= 0) {
          score += net * 10;          // even or favourable trade â€” still ok
        } else {
          score -= (-net) * 25;       // unfavourable â€” heavy penalty
        }
      } else {
        score += 15;                  // free capture (no recapture) â€” bonus
      }
    }

    // â•â• TIER 3: non-capture safety â€” don't move into danger for nothing â•â•
    if (!mv.capture && mv.kind === 'board') {
      const savedFrom = board[mv.fromR][mv.fromC];
      board[mv.fromR][mv.fromC] = null;
      const willBeAttacked = canBeAttackedBy(mv.toR, mv.toC, enemyColor, mv.piece);
      board[mv.fromR][mv.fromC] = savedFrom;

      if (willBeAttacked) {
        // Moving here lets the enemy grab us for free â€” penalise by our value
        score -= movingPV * 22;
        // But if we're the king, extra penalty (losing the king = losing the game)
        if (mv.piece.type === P.KING) score -= 500;
      }
    }

    // â•â• Positional / strategic bonuses â•â•
    if (mv.kind === 'board') {
      // Advance own king toward the enemy back rank (conquest goal)
      if (mv.piece.type === P.KING) {
        const goal = (cpuColor === 'black') ? 3 : 0;
        const advance = Math.abs(mv.fromR - goal) - Math.abs(mv.toR - goal);
        score += advance * 12;
      }
      // Advance own pawn; bonus for reaching promotion rank
      if (mv.piece.type === P.PAWN) {
        const goal = (cpuColor === 'black') ? 3 : 0;
        const advance = Math.abs(mv.fromR - goal) - Math.abs(mv.toR - goal);
        score += advance * 8;
        if (mv.toR === goal) score += 35;   // about to promote
      }
      // Advance queen toward enemy side
      if (mv.piece.type === P.QUEEN) {
        const goal = (cpuColor === 'black') ? 3 : 0;
        const advance = Math.abs(mv.fromR - goal) - Math.abs(mv.toR - goal);
        score += advance * 10;
      }
    }

    // Tray placement: prefer deploying near enemy, prefer stronger pieces
    if (mv.kind === 'place') {
      const goal = (cpuColor === 'black') ? 3 : 0;
      score += (ROWS - 1 - Math.abs(mv.toR - goal)) * 5;
      score += (PIECE_VALUE[mv.type] || 0) * 4;
      // Don't place into immediate danger
      if (canBeAttackedBy(mv.toR, mv.toC, enemyColor, mv.piece)) {
        score -= (PIECE_VALUE[mv.type] || 0) * 18;
      }
    }

    // Tiny jitter so equal-score moves aren't always the same
    score += (Math.random() - 0.5) * 2;
    return score;
  }

  let bestScore = -Infinity, bestMove = null;
  for (const mv of allMoves) {
    const s = scoreMove(mv);
    if (s > bestScore) { bestScore = s; bestMove = mv; }
  }

  if (!bestMove) return;

  if (bestMove.kind === 'board') {
    executeMove(bestMove.fromR, bestMove.fromC, bestMove.toR, bestMove.toC);
  } else {
    // Placement
    selectedTray = { color: bestMove.color, type: bestMove.type, idx: bestMove.idx };
    placeTrayPiece(bestMove.toR, bestMove.toC);
  }
}

// â”€â”€â”€ GAME OVER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function showGameOver(winnerColor, reason) {
  const icon  = document.getElementById('resultIcon');
  const title = document.getElementById('resultTitle');
  const desc  = document.getElementById('resultDesc');
  const wName = winnerColor.charAt(0).toUpperCase() + winnerColor.slice(1);

  if (reason === 'king_captured') {
    icon.textContent  = 'âš”ï¸';
    title.textContent = wName + ' Wins!';
    desc.textContent  = 'The opponent\'s King was captured in battle.';
  } else if (reason === 'king_advance') {
    icon.textContent  = 'ğŸ‘‘';
    title.textContent = wName + ' Wins!';
    desc.textContent  = wName + '\'s King reached the far end and survived â€” conquest complete!';
  } else {
    icon.textContent  = 'ğŸ¤';
    title.textContent = 'Draw';
    desc.textContent  = 'No moves available. The game ends in a draw.';
  }
  document.getElementById('overlay').classList.remove('hidden');
}

function hideOverlay() {
  document.getElementById('overlay').classList.add('hidden');
}

// â”€â”€â”€ TOUCH SCROLL PREVENTION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
document.addEventListener('touchmove', e => {
  if (e.target.closest('.board-wrap') || e.target.closest('.tray')) e.preventDefault();
}, { passive: false });

// â”€â”€â”€ KICK OFF â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
initBoard();
render();
updateStatus();
</script>
</body>
</html>
