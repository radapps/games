<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Knight Duel</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            background: linear-gradient(135deg, #1e293b 0%, #475569 100%);
            min-height: 100vh;
            padding: 20px;
            color: white;
        }

        .container {
            max-width: 800px;
            width: 100%;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
        }

        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #cbd5e1;
        }

        .game-status {
            background: #334155;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            font-size: 1.2em;
            margin-bottom: 20px;
        }

        .winner-message {
            background: #fbbf24;
            color: #1e293b;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            font-size: 1.5em;
            font-weight: bold;
            margin-bottom: 20px;
        }

        .winner-message.hidden {
            display: none;
        }

        .chessboard {
            display: grid;
            gap: 0;
            width: 100%;
            max-width: 600px;
            margin: 0 auto 20px;
            border: 4px solid #0f172a;
            border-radius: 8px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            justify-self: center;
        }
        
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .square {
            aspect-ratio: 1;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2em;
            transition: all 0.2s;
            position: relative;
        }

        .square:hover:not(.burned) {
            opacity: 0.8;
        }

        .square.selected {
            box-shadow: inset 0 0 0 4px #fbbf24;
        }

        .square.valid-move {
            box-shadow: inset 0 0 0 4px var(--highlight-color, #4ade80);
        }
        
        .square.selected {
            box-shadow: inset 0 0 0 4px #fbbf24;
        }

        .square.burned {
            cursor: not-allowed;
        }

        .square img {
            width: 70%;
            height: 70%;
            object-fit: contain;
            filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.5));
        }

        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 20px;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: #3b82f6;
            color: white;
        }

        .btn-primary:hover {
            background: #2563eb;
        }

        .btn-secondary {
            background: #6b7280;
            color: white;
        }

        .btn-secondary:hover {
            background: #4b5563;
        }

        .settings-panel {
            background: #334155;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .settings-panel.hidden {
            display: none;
        }

        .settings-panel h3 {
            margin-bottom: 20px;
        }

        .setting-group {
            margin-bottom: 20px;
        }

        .setting-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
        }

        .setting-group input[type="checkbox"] {
            margin-right: 8px;
        }

        .select {
            width: 100%;
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #475569;
            background: #1e293b;
            color: white;
            font-size: 1em;
        }

        .color-schemes {
            display: flex;
            gap: 10px;
        }

        .color-scheme-btn {
            flex: 1;
            background: #1e293b;
            border: 2px solid #475569;
            border-radius: 8px;
            padding: 10px;
            cursor: pointer;
            color: white;
            transition: all 0.2s;
        }

        .color-scheme-btn:hover {
            border-color: #3b82f6;
        }

        .color-scheme-btn.active {
            border-color: #fbbf24;
            background: #475569;
        }

        .color-preview {
            display: flex;
            gap: 4px;
            margin-top: 8px;
        }

        .color-preview div {
            flex: 1;
            height: 30px;
            border-radius: 4px;
        }

        .rules {
            background: #334155;
            padding: 20px;
            border-radius: 8px;
        }

        .rules.collapsed {
            padding: 0;
            max-height: 0;
            overflow: hidden;
            margin-bottom: 0;
        }

        .rules h3 {
            margin-bottom: 10px;
        }

        .rules ul {
            list-style-position: inside;
            color: #cbd5e1;
        }

        .rules li {
            margin-bottom: 5px;
        }

        @media (max-width: 600px) {
            h1 {
                font-size: 2em;
            }
            
            .square {
                font-size: 1.5em;
            }
            
            .controls {
                flex-direction: column;
            }
            
            .color-schemes {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>‚ôû Knight Duel</h1>
            <p class="subtitle">Two knights enter, one knight leaves</p>
        </div>

        <div id="gameStatus" class="game-status">
            <span id="currentPlayer">Current Turn: Player 1</span>
        </div>

        <div id="winnerMessage" class="winner-message hidden">
            üèÜ <span id="winnerText"></span>
        </div>

        <div id="chessboard" class="chessboard"></div>

        <div class="controls">
            <button id="resetBtn" class="btn btn-primary">New Game</button>
            <button id="settingsBtn" class="btn btn-secondary">Settings</button>
            <button id="rulesBtn" class="btn btn-secondary">Rules</button>
        </div>

        <div id="settingsPanel" class="settings-panel hidden">
            <h3>Settings</h3>
            
            <div class="setting-group">
                <label>Board Color Scheme</label>
                <div class="color-schemes">
                    <button class="color-scheme-btn" data-scheme="0">
                        <span>Classic</span>
                        <div class="color-preview">
                            <div style="background: #F0D9B5"></div>
                            <div style="background: #B58863"></div>
                        </div>
                    </button>
                    <button class="color-scheme-btn" data-scheme="1">
                        <span>Blue</span>
                        <div class="color-preview">
                            <div style="background: #E0E7FF"></div>
                            <div style="background: #4F46E5"></div>
                        </div>
                    </button>
                    <button class="color-scheme-btn" data-scheme="2">
                        <span>Green</span>
                        <div class="color-preview">
                            <div style="background: #DCFCE7"></div>
                            <div style="background: #16A34A"></div>
                        </div>
                    </button>
                </div>
            </div>

            <div class="setting-group">
                <label>Board Size</label>
                <select id="boardSizeSelect" class="select">
                    <option value="5">5x5</option>
                    <option value="6">6x6</option>
                    <option value="7">7x7</option>
                    <option value="8" selected>8x8</option>
                    <option value="9">9x9</option>
                    <option value="10">10x10</option>
                </select>
            </div>

            <div class="setting-group">
                <label>
                    <input type="checkbox" id="allowCaptureCheck" checked>
                    Allow Capturing
                </label>
            </div>

            <div class="setting-group">
                <label>CPU Players</label>
                <label>
                    <input type="checkbox" id="player1CPUCheck">
                    Player 1 is CPU
                </label>
                <label>
                    <input type="checkbox" id="player2CPUCheck">
                    Player 2 is CPU
                </label>
            </div>

            <button id="closeSettingsBtn" class="btn btn-primary">Close Settings (Start New Game)</button>
        </div>

        <div id="rulesPanel" class="rules collapsed">
            <h3>Rules</h3>
            <ul>
                <li>Click your knight to select it</li>
                <li>Click a highlighted square to move</li>
                <li>Squares burn after being vacated</li>
                <li>Win by capturing opponent or trapping them</li>
            </ul>
        </div>
    </div>

    <script>
        class KnightDuelGame {
            constructor() {
                this.boardSize = 8;
                this.board = [];
                this.currentPlayer = 1;
                this.selectedSquare = null;
                this.validMoves = [];
                this.gameOver = false;
                this.winner = null;
                this.colorScheme = 0;
                this.allowCapture = true;
                this.isPlayer1CPU = false;
                this.isPlayer2CPU = false;
                
                this.loadSettings();
                this.initializeBoard();
                this.setupEventListeners();
                this.render();
                
                if (this.isCurrentPlayerCPU()) {
                    setTimeout(() => this.cpuTurn(), 500);
                }
            }
            
            loadSettings() {
                this.colorScheme = parseInt(localStorage.getItem('colorScheme') || '0');
                this.boardSize = parseInt(localStorage.getItem('boardSize') || '8');
                this.allowCapture = localStorage.getItem('allowCapture') !== 'false';
                this.isPlayer1CPU = localStorage.getItem('isPlayer1CPU') === 'true';
                this.isPlayer2CPU = localStorage.getItem('isPlayer2CPU') === 'true';
            }
            
            saveSettings() {
                localStorage.setItem('colorScheme', this.colorScheme);
                localStorage.setItem('boardSize', this.boardSize);
                localStorage.setItem('allowCapture', this.allowCapture);
                localStorage.setItem('isPlayer1CPU', this.isPlayer1CPU);
                localStorage.setItem('isPlayer2CPU', this.isPlayer2CPU);
            }
            
            initializeBoard() {
                this.board = Array(this.boardSize).fill(null).map(() =>
                    Array(this.boardSize).fill(null).map(() => ({ piece: null, burned: false }))
                );
                
                // Player 1 (white) starts bottom-right, Player 2 (black) starts top-left
                this.board[this.boardSize - 1][this.boardSize - 2] = { piece: 1, burned: false };
                this.board[0][1] = { piece: 2, burned: false };
                
                this.currentPlayer = 1;
                this.selectedSquare = null;
                this.validMoves = [];
                this.gameOver = false;
                this.winner = null;
            }
            
            setupEventListeners() {
                document.getElementById('resetBtn').addEventListener('click', () => {
                    this.applySettings();
                    this.reset();
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                });
                document.getElementById('settingsBtn').addEventListener('click', () => {
                    this.toggleSettings();
                    setTimeout(() => window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' }), 100);
                });
                document.getElementById('rulesBtn').addEventListener('click', () => {
                    this.toggleRules();
                    setTimeout(() => window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' }), 100);
                });
                document.getElementById('closeSettingsBtn').addEventListener('click', () => {
                    this.applySettings();
                    this.toggleSettings();
                    this.reset();
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                });
                
                document.querySelectorAll('.color-scheme-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        this.colorScheme = parseInt(e.currentTarget.dataset.scheme);
                        this.updateColorSchemeButtons();
                    });
                });
                
                document.getElementById('player1CPUCheck').addEventListener('change', (e) => {
                    this.isPlayer1CPU = e.target.checked;
                    if (e.target.checked) {
                        document.getElementById('player2CPUCheck').checked = false;
                        this.isPlayer2CPU = false;
                    }
                });
                
                document.getElementById('player2CPUCheck').addEventListener('change', (e) => {
                    this.isPlayer2CPU = e.target.checked;
                    if (e.target.checked) {
                        document.getElementById('player1CPUCheck').checked = false;
                        this.isPlayer1CPU = false;
                    }
                });
            }
            
            toggleSettings() {
                const panel = document.getElementById('settingsPanel');
                panel.classList.toggle('hidden');
                
                if (!panel.classList.contains('hidden')) {
                    this.updateSettingsUI();
                }
            }
            
            toggleRules() {
                const panel = document.getElementById('rulesPanel');
                panel.classList.toggle('collapsed');
            }
            
            updateSettingsUI() {
                this.updateColorSchemeButtons();
                document.getElementById('boardSizeSelect').value = this.boardSize;
                document.getElementById('allowCaptureCheck').checked = this.allowCapture;
                document.getElementById('player1CPUCheck').checked = this.isPlayer1CPU;
                document.getElementById('player2CPUCheck').checked = this.isPlayer2CPU;
            }
            
            updateColorSchemeButtons() {
                document.querySelectorAll('.color-scheme-btn').forEach(btn => {
                    btn.classList.toggle('active', parseInt(btn.dataset.scheme) === this.colorScheme);
                });
            }
            
            applySettings() {
                this.boardSize = parseInt(document.getElementById('boardSizeSelect').value);
                this.allowCapture = document.getElementById('allowCaptureCheck').checked;
                this.isPlayer1CPU = document.getElementById('player1CPUCheck').checked;
                this.isPlayer2CPU = document.getElementById('player2CPUCheck').checked;
                this.saveSettings();
            }
            
            getKnightMoves(row, col) {
                const moves = [
                    [-2, -1], [-2, 1], [-1, -2], [-1, 2],
                    [1, -2], [1, 2], [2, -1], [2, 1]
                ];
                
                const validMoves = [];
                
                moves.forEach(([dr, dc]) => {
                    const newRow = row + dr;
                    const newCol = col + dc;
                    
                    if (newRow >= 0 && newRow < this.boardSize && newCol >= 0 && newCol < this.boardSize) {
                        const square = this.board[newRow][newCol];
                        if (square.burned) return;
                        
                        if (!this.allowCapture && square.piece && square.piece !== this.currentPlayer) {
                            return;
                        }
                        
                        validMoves.push([newRow, newCol]);
                    }
                });
                
                return validMoves;
            }
            
            findKnight(player) {
                for (let row = 0; row < this.boardSize; row++) {
                    for (let col = 0; col < this.boardSize; col++) {
                        if (this.board[row][col].piece === player) {
                            return [row, col];
                        }
                    }
                }
                return null;
            }
            
            handleSquareClick(row, col) {
                if (this.gameOver || this.isCurrentPlayerCPU()) return;
                
                const square = this.board[row][col];
                
                if (square.piece === this.currentPlayer) {
                    this.selectedSquare = [row, col];
                    this.validMoves = this.getKnightMoves(row, col);
                    this.render();
                    return;
                }
                
                if (this.selectedSquare) {
                    const isValid = this.validMoves.some(([r, c]) => r === row && c === col);
                    
                    if (isValid) {
                        this.makeMove(this.selectedSquare, [row, col]);
                    }
                    
                    this.selectedSquare = null;
                    this.validMoves = [];
                    this.render();
                }
            }
            
            makeMove(from, to) {
                const [fromRow, fromCol] = from;
                const [toRow, toCol] = to;
                
                const capturedPiece = this.board[toRow][toCol].piece;
                
                this.board[toRow][toCol] = { piece: this.currentPlayer, burned: false };
                this.board[fromRow][fromCol] = { piece: null, burned: true };
                
                if (this.allowCapture && capturedPiece) {
                    this.gameOver = true;
                    this.winner = this.currentPlayer;
                    this.render();
                    return;
                }
                
                this.currentPlayer = this.currentPlayer === 1 ? 2 : 1;
                
                const nextKnightPos = this.findKnight(this.currentPlayer);
                if (!nextKnightPos || this.getKnightMoves(nextKnightPos[0], nextKnightPos[1]).length === 0) {
                    this.gameOver = true;
                    this.winner = this.currentPlayer === 1 ? 2 : 1;
                }
                
                this.render();
                
                if (this.isCurrentPlayerCPU() && !this.gameOver) {
                    setTimeout(() => this.cpuTurn(), 1000);
                }
            }
            
            isCurrentPlayerCPU() {
                return (this.currentPlayer === 1 && this.isPlayer1CPU) ||
                       (this.currentPlayer === 2 && this.isPlayer2CPU);
            }
            
            async cpuTurn() {
                if (!this.isCurrentPlayerCPU() || this.gameOver) return;
                
                const knightPos = this.findKnight(this.currentPlayer);
                if (!knightPos) return;
                
                this.selectedSquare = knightPos;
                this.validMoves = this.getKnightMoves(knightPos[0], knightPos[1]);
                this.render();
                
                await new Promise(resolve => setTimeout(resolve, 500));
                
                const move = this.chooseBestCPUMove(knightPos, this.validMoves);
                if (move) {
                    this.makeMove(knightPos, move);
                }
                
                this.selectedSquare = null;
                this.validMoves = [];
                this.render();
            }
            
            chooseBestCPUMove(knightPos, possibleMoves) {
                if (possibleMoves.length === 0) return null;
                
                const opponentPlayer = this.currentPlayer === 1 ? 2 : 1;
                const opponentPos = this.findKnight(opponentPlayer);
                
                // If capturing is allowed, check if we can capture the opponent
                if (this.allowCapture && opponentPos) {
                    const captureMove = possibleMoves.find(([row, col]) => 
                        row === opponentPos[0] && col === opponentPos[1]
                    );
                    if (captureMove) {
                        return captureMove; // Take the win!
                    }
                }
                
                const dangerSquares = opponentPos ? this.getKnightMoves(opponentPos[0], opponentPos[1]) : [];
                
                const safeMoves = possibleMoves.filter(([row, col]) =>
                    !dangerSquares.some(([r, c]) => r === row && c === col)
                );
                
                const movesToUse = safeMoves.length > 0 ? safeMoves : possibleMoves;
                return movesToUse[Math.floor(Math.random() * movesToUse.length)];
            }
            
            getSquareColor(row, col) {
                const isLight = (row + col) % 2 === 0;
                
                const schemes = [
                    { light: '#F0D9B5', dark: '#B58863' },
                    { light: '#E0E7FF', dark: '#4F46E5' },
                    { light: '#DCFCE7', dark: '#16A34A' }
                ];
                
                const scheme = schemes[this.colorScheme];
                return isLight ? scheme.light : scheme.dark;
            }
            
            render() {
                const boardEl = document.getElementById('chessboard');
                boardEl.innerHTML = '';
                boardEl.style.gridTemplateColumns = `repeat(${this.boardSize}, 1fr)`;
                boardEl.style.gridTemplateRows = `repeat(${this.boardSize}, 1fr)`;
                
                // Set highlight color based on color scheme
                const highlightColor = this.colorScheme === 2 ? '#fbbf24' : '#4ade80'; // Yellow for green scheme, green for others
                boardEl.style.setProperty('--highlight-color', highlightColor);
                
                for (let row = 0; row < this.boardSize; row++) {
                    for (let col = 0; col < this.boardSize; col++) {
                        const square = this.board[row][col];
                        const squareEl = document.createElement('button');
                        squareEl.className = 'square';
                        squareEl.style.background = this.getSquareColor(row, col);
                        
                        if (this.selectedSquare && this.selectedSquare[0] === row && this.selectedSquare[1] === col) {
                            squareEl.classList.add('selected');
                        }
                        
                        if (this.validMoves.some(([r, c]) => r === row && c === col)) {
                            squareEl.classList.add('valid-move');
                        }
                        
                        if (square.burned) {
                            squareEl.classList.add('burned');
                            const img = document.createElement('img');
                            img.src = 'assets/flame.png';
                            img.alt = 'Burned';
                            squareEl.appendChild(img);
                        } else if (square.piece === 1) {
                            const img = document.createElement('img');
                            img.src = 'assets/knight_white.png';
                            img.alt = 'Player 1 Knight';
                            squareEl.appendChild(img);
                        } else if (square.piece === 2) {
                            const img = document.createElement('img');
                            img.src = 'assets/knight_black.png';
                            img.alt = 'Player 2 Knight';
                            squareEl.appendChild(img);
                        }
                        
                        squareEl.addEventListener('click', () => this.handleSquareClick(row, col));
                        boardEl.appendChild(squareEl);
                    }
                }
                
                document.getElementById('currentPlayer').textContent = `Current Turn: Player ${this.currentPlayer}`;
                
                const winnerMsg = document.getElementById('winnerMessage');
                if (this.gameOver && this.winner) {
                    winnerMsg.classList.remove('hidden');
                    document.getElementById('winnerText').textContent = `Player ${this.winner} Wins!`;
                    document.getElementById('gameStatus').style.display = 'none';
                } else {
                    winnerMsg.classList.add('hidden');
                    document.getElementById('gameStatus').style.display = 'block';
                }
            }
            
            reset() {
                this.initializeBoard();
                this.render();
                
                if (this.isCurrentPlayerCPU()) {
                    setTimeout(() => this.cpuTurn(), 500);
                }
            }
        }

        // Start the game when page loads
        window.addEventListener('DOMContentLoaded', () => {
            new KnightDuelGame();
        });
    </script>
</body>
</html>
