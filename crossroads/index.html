<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>BBS Terminal</title>
    <link href="https://fonts.googleapis.com/css2?family=VT323&family=IBM+Plex+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --accent-primary: #58a6ff;
            --accent-secondary: #79c0ff;
            --accent-success: #3fb950;
            --accent-warning: #d29922;
            --accent-danger: #f85149;
            --text-primary: #c9d1d9;
            --text-secondary: #8b949e;
            --border-default: #30363d;
            --border-muted: #21262d;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'IBM Plex Mono', monospace;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
        }

        .container {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Login Panel */
        .login-panel {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .login-panel.hidden {
            display: none;
        }

        .login-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-default);
            border-radius: 12px;
            padding: 32px;
            width: 100%;
            max-width: 480px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
        }

        .login-card h2 {
            font-size: 1.5em;
            margin-bottom: 8px;
            color: var(--text-primary);
        }

        .login-card p {
            color: var(--text-secondary);
            margin-bottom: 24px;
            font-size: 0.9em;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            color: var(--text-secondary);
            font-size: 0.85em;
            font-weight: 500;
        }

        .form-group input {
            width: 100%;
            padding: 10px 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-default);
            border-radius: 6px;
            color: var(--text-primary);
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.9em;
            transition: all 0.2s ease;
        }

        .form-group input:focus {
            outline: none;
            border-color: var(--accent-primary);
            background: var(--bg-secondary);
        }

        .connect-btn {
            width: 100%;
            padding: 12px;
            background: var(--accent-primary);
            border: none;
            border-radius: 6px;
            color: #ffffff;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.95em;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .connect-btn:hover {
            background: var(--accent-secondary);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(88, 166, 255, 0.3);
        }

        .connect-btn:active {
            transform: translateY(0);
        }

        /* Main Content */
        .main-content {
            flex: 1;
            display: none;
            flex-direction: column;
            min-height: 0;
        }

        .main-content.active {
            display: flex;
        }

        /* Terminal - Top Half */
        .terminal-container {
            height: 55vh;
            display: flex;
            flex-direction: column;
            padding: 8px 8px 0 8px;
        }

        .terminal {
            flex: 1;
            background: #000000;
            border: 1px solid var(--border-default);
            border-radius: 8px;
            padding: 16px;
            overflow-y: auto;
            font-family: 'VT323', monospace;
            font-size: 1.2em;
            line-height: 1.3;
            color: #ffffff;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .terminal::-webkit-scrollbar {
            width: 10px;
        }

        .terminal::-webkit-scrollbar-track {
            background: #000000;
        }

        .terminal::-webkit-scrollbar-thumb {
            background: var(--border-default);
            border-radius: 5px;
        }

        .terminal::-webkit-scrollbar-thumb:hover {
            background: var(--text-secondary);
        }

        /* Bottom Controls Area */
        .controls-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 8px;
            gap: 4px;
            overflow-y: auto;
            min-height: 0;
        }

        .controls-area::-webkit-scrollbar {
            width: 8px;
        }

        .controls-area::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        .controls-area::-webkit-scrollbar-thumb {
            background: var(--border-default);
            border-radius: 4px;
        }

        .controls-area::-webkit-scrollbar-thumb:hover {
            background: var(--text-secondary);
        }

        /* Popup Modal for Button Lists */
        .popup-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .popup-overlay.active {
            display: flex;
        }

        .popup-container {
            background: var(--bg-secondary);
            border: 2px solid var(--accent-primary);
            border-radius: 8px;
            width: 90%;
            max-width: 400px;
            max-height: 70vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        .popup-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            border-bottom: 1px solid var(--border-default);
        }

        .popup-title {
            font-size: 1.1em;
            font-weight: 500;
            color: var(--accent-primary);
        }

        .popup-close {
            width: 32px;
            height: 32px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-default);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 1.2em;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .popup-close:hover {
            background: var(--accent-danger);
            border-color: var(--accent-danger);
            color: #ffffff;
        }

        .popup-content {
            padding: 16px;
            overflow-y: auto;
            flex: 1;
        }

        .popup-content::-webkit-scrollbar {
            width: 8px;
        }

        .popup-content::-webkit-scrollbar-track {
            background: var(--bg-tertiary);
        }

        .popup-content::-webkit-scrollbar-thumb {
            background: var(--border-default);
            border-radius: 4px;
        }

        .popup-content::-webkit-scrollbar-thumb:hover {
            background: var(--text-secondary);
        }

        .popup-button-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .popup-list-btn {
            padding: 12px 16px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-default);
            border-radius: 6px;
            color: var(--text-primary);
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: left;
        }

        .popup-list-btn:hover {
            background: var(--bg-primary);
            border-color: var(--accent-primary);
            transform: translateX(4px);
        }

        .popup-list-btn:active {
            transform: translateX(2px);
        }

        /* Input Row */
        .input-row {
            display: flex;
            gap: 12px;
        }

        .input-wrapper {
            flex: 1;
            display: flex;
            gap: 8px;
        }

        .input-wrapper input {
            flex: 1;
            padding: 10px 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-default);
            border-radius: 6px;
            color: var(--text-primary);
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.9em;
        }

        .input-wrapper input:focus {
            outline: none;
            border-color: var(--accent-primary);
        }

        .send-btn {
            padding: 10px 20px;
            background: var(--accent-primary);
            border: none;
            border-radius: 6px;
            color: #ffffff;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.9em;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .send-btn:hover {
            background: var(--accent-secondary);
        }

        /* Button Rows */
        .buttons-row {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .all-buttons-container {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .button-row {
            display: flex;
            gap: 4px;
            justify-content: center;
            align-items: center;
        }

        .button-spacer {
            width: 48px;
            height: 48px;
        }

        .control-btn {
            padding: 4px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-default);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 1.6em;
            cursor: pointer;
            transition: all 0.15s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 48px;
            height: 48px;
        }

        .control-btn:hover:not(:disabled) {
            background: var(--bg-primary);
            border-color: var(--accent-primary);
            transform: scale(1.05);
        }

        .control-btn:active:not(:disabled) {
            transform: scale(0.95);
        }

        .control-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        /* Target buttons - hidden by default */
        .target-buttons {
            display: none;
            flex-direction: column;
            gap: 2px;
            margin-top: 2px;
            position: absolute;
            z-index: 100;
            min-width: 120px;
        }

        .target-buttons.active {
            display: flex;
        }

        .target-btn {
            padding: 4px 8px;
            background: var(--bg-tertiary);
            border: 1px solid var(--accent-warning);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 0.75em;
            cursor: pointer;
            transition: all 0.15s ease;
            text-align: left;
            white-space: nowrap;
        }

        .target-btn:hover {
            background: var(--bg-primary);
            border-color: var(--accent-primary);
        }

        /* Spell buttons */
        .spell-buttons {
            display: none;
            flex-direction: column;
            gap: 2px;
            margin-top: 2px;
            position: absolute;
            z-index: 100;
            min-width: 120px;
        }

        .spell-buttons.active {
            display: flex;
        }

        .spell-btn {
            padding: 4px 8px;
            background: var(--bg-tertiary);
            border: 1px solid var(--accent-primary);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 0.75em;
            cursor: pointer;
            transition: all 0.15s ease;
            text-align: left;
            white-space: nowrap;
        }

        .spell-btn:hover {
            background: var(--bg-primary);
            border-color: var(--accent-secondary);
        }

        /* Dynamic Buttons */
        .dynamic-section {
            display: none;
        }

        .dynamic-section.active {
            display: block;
        }

        .dynamic-btn {
            background: linear-gradient(135deg, rgba(255, 165, 0, 0.15), rgba(255, 215, 0, 0.15));
            border-color: var(--accent-warning);
        }

        .dynamic-btn:hover {
            background: linear-gradient(135deg, rgba(255, 165, 0, 0.25), rgba(255, 215, 0, 0.25));
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .terminal-container {
                height: 50vh;
            }

            .terminal {
                font-size: 0.7em;
            }

            .buttons-row {
                flex-direction: column;
                gap: 4px;
            }
        }

        @media (max-width: 600px) {
            .header {
                padding: 10px 12px;
            }

            .header-title h1 {
                font-size: 1.4em;
            }

            .login-card {
                padding: 24px;
            }

            .key-btn {
                min-width: 32px;
                height: 36px;
                font-size: 0.8em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Login Panel -->
        <div class="login-panel" id="loginPanel">
            <div class="login-card">
                <h2>Connect to BBS</h2>
                <p>Enter connection details and credentials</p>
                <div class="form-group">
                    <label for="wsUrl">WebSocket URL</label>
                    <input type="text" id="wsUrl" placeholder="wss://server.com/host/port" value="wss://unabruptly-multiplated-kory.ngrok-free.dev:443/192.168.40.69/23">
                </div>
                <div class="form-group">
                    <label for="username">Username</label>
                    <input type="text" id="username" placeholder="Your username">
                </div>
                <div class="form-group">
                    <label for="password">Password</label>
                    <input type="password" id="password" placeholder="Your password">
                </div>
                <button class="connect-btn" onclick="connect()">Connect</button>
            </div>
        </div>

        <!-- Main Content -->
        <div class="main-content" id="mainContent">
            <!-- Terminal - Top Half -->
            <div class="terminal-container">
                <div class="terminal" id="terminal"></div>
            </div>

            <!-- Bottom Controls Area -->
            <div class="controls-area">
                <!-- Input Row -->
                <div class="input-row">
                    <div class="input-wrapper">
                        <input type="text" id="commandInput" placeholder="Type command..." onkeypress="handleEnter(event)">
                        <button class="send-btn" onclick="sendCurrentInput()">Send</button>
                    </div>
                </div>

                <!-- Buttons Row -->
                <div class="buttons-row">
                    <div class="all-buttons-container">
                        <!-- Row 1: HIT, CAST, DRINK, <empty>, D, N, U -->
                        <div class="button-row">
                            <button class="control-btn" onclick="handleHitButton()" title="Hit">‚öîÔ∏è</button>
                            <button class="control-btn" onclick="handleCastButton()" title="Cast">üìñ</button>
                            <button class="control-btn" onclick="handleDrinkButton()" title="Drink">üíß</button>
                            <div class="button-spacer"></div>
                            <button class="control-btn" id="btnD" onclick="sendDirectional('d')" title="Down">‚§µÔ∏è</button>
                            <button class="control-btn" id="btnN" onclick="sendDirectional('n')" title="North">‚¨ÜÔ∏è</button>
                            <button class="control-btn" id="btnU" onclick="sendDirectional('u')" title="Up">‚§¥Ô∏è</button>
                        </div>
                        
                        <!-- Row 2: I, LOOK, HITS, <empty>, W, EX, E -->
                        <div class="button-row">
                            <button class="control-btn" onclick="sendCommand('i')" title="Inventory">üëú</button>
                            <button class="control-btn" onclick="sendCommand('look')" title="Look">üëÅÔ∏è</button>
                            <button class="control-btn" onclick="sendCommand('hits')" title="HP/SP">‚ù§Ô∏è‚Äçü©π</button>
                            <div class="button-spacer"></div>
                            <button class="control-btn" id="btnW" onclick="sendDirectional('w')" title="West">‚¨ÖÔ∏è</button>
                            <button class="control-btn" onclick="handleExitsButton()" title="Exits">üö™</button>
                            <button class="control-btn" id="btnE" onclick="sendDirectional('e')" title="East">‚û°Ô∏è</button>
                        </div>
                        
                        <!-- Row 3: Help, Social, Stats, <empty>, <empty>, S, <empty> -->
                        <div class="button-row">
                            <button class="control-btn" onclick="handleHelpButton()" title="Help">‚ùì</button>
                            <button class="control-btn" onclick="handleSocialButton()" title="Social">üòÄ</button>
                            <button class="control-btn" onclick="sendCommand('stats')" title="Stats">üìä</button>
                            <div class="button-spacer"></div>
                            <div class="button-spacer"></div>
                            <button class="control-btn" id="btnS" onclick="sendDirectional('s')" title="South">‚¨áÔ∏è</button>
                            <div class="button-spacer"></div>
                        </div>

                        <!-- Row 4: Shop, <empty>, <empty>, <empty>, <empty>, <empty>, <empty> -->
                        <div class="button-row">
                            <button class="control-btn" onclick="handleShopButton()" title="Shop">üí≤</button>
                            <div class="button-spacer"></div>
                            <div class="button-spacer"></div>
                            <div class="button-spacer"></div>
                            <div class="button-spacer"></div>
                            <div class="button-spacer"></div>
                            <div class="button-spacer"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Popup Modal for Button Lists -->
    <div class="popup-overlay" id="popupOverlay" onclick="closePopupIfClickedOutside(event)">
        <div class="popup-container" onclick="event.stopPropagation()">
            <div class="popup-header">
                <div class="popup-title" id="popupTitle">Select</div>
                <button class="popup-close" onclick="closePopup()">‚úï</button>
            </div>
            <div class="popup-content">
                <div class="popup-button-list" id="popupButtonList"></div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let ws = null;
        let isConnected = false;
        let currentTerminalText = '';
        let recentTerminalText = '';
        let currentTargets = []; // Store current targets from "There is a ... here."
        let currentANSIStyle = ''; // Persist ANSI color state across chunks
        let currentSpells = []; // Store user's spells
        let selectedSpell = null; // Currently selected spell for casting
        let waitingForSpells = false; // Waiting for spell list from server
        let waitingForExits = false; // Waiting for exit list from server
        let currentPotions = []; // Store available potions
        let waitingForPotions = false; // Waiting for inventory to extract potions
        let waitingForSpellRefresh = false; // Waiting to check if CAST failed and needs spell list
        let waitingForShopItems = false; // Waiting for shop inventory
        let waitingForSellItems = false; // Waiting for sell inventory
        let waitingForAppraiseItems = false; // Waiting for appraise inventory
        let currentShopkeeper = null; // Current shopkeeper name

        // Popup control functions
        function showPopup(title, buttons, onClickCallback) {
            const overlay = document.getElementById('popupOverlay');
            const titleEl = document.getElementById('popupTitle');
            const listEl = document.getElementById('popupButtonList');
            
            titleEl.textContent = title;
            listEl.innerHTML = '';
            
            buttons.forEach(button => {
                const btn = document.createElement('button');
                btn.className = 'popup-list-btn';
                btn.textContent = button.label || button;
                btn.onclick = () => {
                    onClickCallback(button.value || button);
                    closePopup();
                };
                listEl.appendChild(btn);
            });
            
            overlay.classList.add('active');
        }

        function closePopup() {
            const overlay = document.getElementById('popupOverlay');
            overlay.classList.remove('active');
        }

        function closePopupIfClickedOutside(event) {
            if (event.target.id === 'popupOverlay') {
                closePopup();
            }
        }

        // Telnet IAC (Interpret As Command) constants
        const IAC = 255;  // 0xFF
        const DONT = 254; // 0xFE
        const DO = 253;   // 0xFD
        const WONT = 252; // 0xFC
        const WILL = 251; // 0xFB
        const SB = 250;   // 0xFA - Subnegotiation Begin
        const SE = 240;   // 0xF0 - Subnegotiation End

        // ANSI color map
        const ANSI_COLORS = {
            '0': 'color: #ffffff',      // Reset to white
            '30': 'color: #484f58',     // Black
            '31': 'color: #ff7b72',     // Red
            '32': 'color: #3fb950',     // Green
            '33': 'color: #d29922',     // Yellow
            '34': 'color: #58a6ff',     // Blue
            '35': 'color: #bc8cff',     // Magenta
            '36': 'color: #76e3ea',     // Cyan
            '37': 'color: #ffffff',     // White
            '90': 'color: #6e7681',     // Bright Black (Gray)
            '91': 'color: #ffa198',     // Bright Red
            '92': 'color: #56d364',     // Bright Green
            '93': 'color: #e3b341',     // Bright Yellow
            '94': 'color: #79c0ff',     // Bright Blue
            '95': 'color: #d2a8ff',     // Bright Magenta
            '96': 'color: #b3f0ff',     // Bright Cyan
            '97': 'color: #f0f6fc',     // Bright White
        };

        // Dynamic button rules
        const dynamicButtonRules = [
            {
                trigger: /enemy|monster|goblin|dragon|combat|fight/i,
                buttons: [
                    { icon: '‚öîÔ∏è', command: 'attack', title: 'Attack' },
                    { icon: 'üõ°Ô∏è', command: 'defend', title: 'Defend' },
                    { icon: 'üèÉ', command: 'flee', title: 'Flee' }
                ]
            },
            {
                trigger: /merchant|shop|store|buy|sell/i,
                buttons: [
                    { icon: 'üí∞', command: 'buy', title: 'Buy' },
                    { icon: 'üí∏', command: 'sell', title: 'Sell' },
                    { icon: 'üìã', command: 'list', title: 'List' }
                ]
            },
            {
                trigger: /treasure|chest|loot/i,
                buttons: [
                    { icon: 'üì¶', command: 'get all', title: 'Get All' },
                    { icon: 'üîç', command: 'examine', title: 'Examine' }
                ]
            }
        ];

        // Load saved credentials
        window.addEventListener('DOMContentLoaded', () => {
            const saved = {
                wsUrl: localStorage.getItem('bbs_ws_url'),
                username: localStorage.getItem('bbs_username'),
                password: localStorage.getItem('bbs_password')
            };
            
            if (saved.wsUrl) document.getElementById('wsUrl').value = saved.wsUrl;
            if (saved.username) document.getElementById('username').value = saved.username;
            if (saved.password) document.getElementById('password').value = saved.password;
        });

        function connect() {
            const wsUrl = document.getElementById('wsUrl').value.trim();
            const username = document.getElementById('username').value.trim();
            const password = document.getElementById('password').value.trim();

            if (!wsUrl) {
                alert('Please enter a WebSocket URL');
                return;
            }

            // Save credentials
            localStorage.setItem('bbs_ws_url', wsUrl);
            localStorage.setItem('bbs_username', username);
            localStorage.setItem('bbs_password', password);

            // Hide login, show terminal
            document.getElementById('loginPanel').classList.add('hidden');
            document.getElementById('mainContent').classList.add('active');

            // Clear terminal
            document.getElementById('terminal').innerHTML = '';
            currentTerminalText = '';
            recentTerminalText = '';

            appendToTerminal('Connecting to ' + wsUrl + '...\n');

            try {
                ws = new WebSocket(wsUrl);
                ws.binaryType = 'arraybuffer';  // Important for binary telnet data!

                ws.onopen = function() {
                    isConnected = true;
                    appendToTerminal('‚úì Connected!\n\n');
                    
                    // Auto-login sequence
                    if (username && password) {
                        setTimeout(() => sendCommand(username), 3000);
                        setTimeout(() => sendCommand(password), 3100);
                        setTimeout(() => sendCommand('q'), 3600);  // 500ms after password
                        setTimeout(() => sendCommand('g'), 3800);  // 200ms after Q
                        setTimeout(() => sendCommand('q'), 4000);  // 200ms after G
                        setTimeout(() => sendCommand('5'), 4200);  // 200ms after Q
                        setTimeout(() => sendCommand('p'), 4400);  // 200ms after 5
                    }
                };

                ws.onmessage = function(event) {
                    let data;
                    
                    // Handle binary data
                    if (event.data instanceof ArrayBuffer) {
                        const bytes = new Uint8Array(event.data);
                        const filtered = filterTelnetIAC(bytes);
                        data = new TextDecoder('utf-8').decode(filtered);
                    } else {
                        data = event.data;
                    }

                    if (data.length > 0) {
                        appendToTerminal(data);
                        
                        // Store text for dynamic buttons and target extraction
                        const plainText = stripANSI(data);
                        currentTerminalText += plainText;
                        recentTerminalText += plainText;
                        
                        // Keep buffers manageable
                        if (currentTerminalText.length > 10000) {
                            currentTerminalText = currentTerminalText.slice(-10000);
                        }
                        if (recentTerminalText.length > 1000) {
                            recentTerminalText = recentTerminalText.slice(-1000);
                        }
                        
                        // Extract targets from recent text
                        updateTargets();
                        
                        // Extract spells if waiting for them
                        if (waitingForSpells) {
                            extractSpells();
                        }
                        
                        // Extract exits if waiting for them
                        if (waitingForExits) {
                            extractExits();
                        }
                        
                        // Extract potions if waiting for them
                        if (waitingForPotions) {
                            extractPotions();
                        }
                        
                        // Check for spell refresh needed
                        if (waitingForSpellRefresh) {
                            checkForSpellRefresh();
                        }
                        
                        // Check for item drops
                        checkForItemDrops(plainText);
                        
                        // Extract shop items if waiting
                        if (waitingForShopItems) {
                            extractShopItems();
                        }
                        
                        // Extract sell/appraise items if waiting
                        if (waitingForSellItems || waitingForAppraiseItems) {
                            extractInventoryForShop();
                        }
                    }
                };

                ws.onerror = function(error) {
                    console.error('WebSocket error:', error);
                    isConnected = false;
                    appendToTerminal('\n‚úó Connection error\n');
                };

                ws.onclose = function(event) {
                    console.log('WebSocket closed:', event.code, event.reason);
                    isConnected = false;
                    appendToTerminal('\n[Connection closed]\n');
                };
            } catch (e) {
                appendToTerminal('\n‚úó Error: ' + e.message + '\n');
            }
        }

        function filterTelnetIAC(bytes) {
            const filtered = [];
            let i = 0;

            while (i < bytes.length) {
                if (bytes[i] === IAC) {
                    // Check for IAC IAC (escaped 255)
                    if (i + 1 < bytes.length && bytes[i + 1] === IAC) {
                        filtered.push(IAC);
                        i += 2;
                        continue;
                    }

                    // Handle IAC commands
                    if (i + 2 < bytes.length) {
                        const cmd = bytes[i + 1];
                        
                        // Check for subnegotiation
                        if (cmd === SB) {
                            // Skip until SE
                            i += 2;
                            while (i < bytes.length && !(bytes[i] === IAC && i + 1 < bytes.length && bytes[i + 1] === SE)) {
                                i++;
                            }
                            i += 2; // Skip IAC SE
                            continue;
                        }
                        
                        // Skip DO, DONT, WILL, WONT commands (3 bytes)
                        if (cmd === DO || cmd === DONT || cmd === WILL || cmd === WONT) {
                            i += 3;
                            continue;
                        }
                    }
                    
                    i++;
                } else {
                    filtered.push(bytes[i]);
                    i++;
                }
            }

            return new Uint8Array(filtered);
        }

        function appendToTerminal(text) {
            const terminal = document.getElementById('terminal');
            const processed = processANSI(text);
            terminal.innerHTML += processed;
            terminal.scrollTop = terminal.scrollHeight;
        }

        function stripANSI(text) {
            return text.replace(/\x1b\[[0-9;]*m/g, '').replace(/\x1b\[.*?[@-~]/g, '');
        }

        function processANSI(text) {
            // Escape HTML
            text = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

            // Process ANSI escape codes
            const regex = /\x1b\[([0-9;]*)m/g;
            let result = '';
            let lastIndex = 0;

            text.replace(regex, (match, codes, offset) => {
                // Add text before this code
                if (offset > lastIndex) {
                    const textBefore = text.substring(lastIndex, offset);
                    if (currentANSIStyle) {
                        result += `<span style="${currentANSIStyle}">${textBefore}</span>`;
                    } else {
                        result += textBefore;
                    }
                }

                // Update style based on codes
                const codeList = codes.split(';').filter(c => c);
                for (const code of codeList) {
                    if (ANSI_COLORS[code]) {
                        currentANSIStyle = ANSI_COLORS[code];
                    } else if (code === '0' || code === '') {
                        currentANSIStyle = 'color: #ffffff'; // Reset to white
                    }
                }

                lastIndex = offset + match.length;
                return '';
            });

            // Add remaining text with current style
            if (lastIndex < text.length) {
                const textAfter = text.substring(lastIndex);
                if (currentANSIStyle) {
                    result += `<span style="${currentANSIStyle}">${textAfter}</span>`;
                } else {
                    result += textAfter;
                }
            }

            return result;
        }

        function sendCommand(command) {
            if (!isConnected || !ws || ws.readyState !== WebSocket.OPEN) {
                alert('Not connected');
                return;
            }

            try {
                // Send as binary (Uint8Array) instead of text
                const encoder = new TextEncoder();
                const data = encoder.encode(command + '\r\n');
                ws.send(data.buffer);
            } catch (e) {
                console.error('Send error:', e);
            }
        }

        function sendDirectional(direction) {
            // Clear targets when moving
            currentTargets = [];
            
            // Re-enable all nav buttons when moving
            enableAllNavButtons();
            
            // Send the directional command
            sendCommand(direction);
            
            // Auto-trigger exits check after a short delay
            setTimeout(() => {
                handleExitsButton();
            }, 500);
        }

        function handleExitsButton() {
            // Request exits from server
            waitingForExits = true;
            sendCommand('ex');
        }

        function extractTargets(text) {
            // Look for pattern: "There is a ... here."
            const regex = /There is (?:a |an )?(.*?) here\./gi;
            const matches = [...text.matchAll(regex)];
            
            if (matches.length > 0) {
                // Get the last match (most recent)
                const lastMatch = matches[matches.length - 1];
                const targetString = lastMatch[1];
                
                // Split by "and" and commas to get individual targets
                const targets = targetString
                    .split(/(?:\s+and\s+|,\s*)/)
                    .map(t => t.trim())
                    .map(t => t.replace(/^(a |an )/i, '')) // Remove "a" or "an" prefix
                    .filter(t => t.length > 0);
                
                return targets;
            }
            
            return [];
        }

        function extractSpells() {
            // Look for "You have the ability to cast:" followed by spell names
            const regex = /You have the ability to cast:\s*([^\n]+)/i;
            const match = recentTerminalText.match(regex);
            
            if (match) {
                const spellString = match[1];
                // Split by spaces and/or tabs
                const spells = spellString
                    .split(/[\s\t]+/)
                    .map(s => s.trim())
                    .filter(s => s.length > 0);
                
                if (spells.length > 0) {
                    currentSpells = spells;
                    waitingForSpells = false;
                    console.log('Spells found:', spells);
                    // Auto-show spell list in popup
                    showPopup('Select Spell', currentSpells, (spell) => {
                        selectedSpell = spell;
                        if (currentTargets.length > 0) {
                            showPopup('Select Target', currentTargets, (target) => {
                                sendCommand('cast ' + selectedSpell + ' ' + target);
                                selectedSpell = null;
                                waitingForSpellRefresh = true;
                                setTimeout(() => sendCommand('hits'), 100);
                            });
                        } else {
                            sendCommand('cast ' + selectedSpell);
                            selectedSpell = null;
                        }
                    });
                }
            }
        }

        function handleShopAction(action) {
            if (action === 'Buy') {
                // Find shopkeeper and look at them
                const shopkeeperMatch = recentTerminalText.match(/(\w+)\s+is here\./i);
                if (shopkeeperMatch) {
                    currentShopkeeper = shopkeeperMatch[1];
                    waitingForShopItems = true;
                    sendCommand('look ' + currentShopkeeper);
                } else {
                    alert('No shopkeeper found in the room');
                }
            } else if (action === 'Sell') {
                waitingForSellItems = true;
                sendCommand('i');
            } else if (action === 'Appraise') {
                waitingForAppraiseItems = true;
                sendCommand('i');
            }
        }

        function extractShopItems() {
            // Look for shop inventory format: "Qty  Price  <item>"
            const lines = recentTerminalText.split('\n');
            const items = [];
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                // Match lines with numbers (qty and price) followed by item name
                const match = line.match(/^\d+\s+\d+\s+(.+)$/);
                if (match) {
                    items.push(match[1].trim());
                }
            }
            
            if (items.length > 0) {
                waitingForShopItems = false;
                showShopItemButtons(items, 'buy');
            }
        }

        function extractInventoryForShop() {
            // Look for "You are holding" - use lastIndexOf to find the most recent occurrence
            const searchText = 'You are holding';
            const lastIndex = recentTerminalText.lastIndexOf(searchText);
            
            if (lastIndex !== -1) {
                // Extract text after "You are holding"
                const afterText = recentTerminalText.substring(lastIndex + searchText.length);
                
                // Take until newline or period
                const match = afterText.match(/^([^\n.]+)/);
                
                if (match) {
                    const itemString = match[1];
                    
                    // Split by commas and "and", then clean up
                    const items = itemString
                        .replace(/\s+and\s+/gi, ',') // Replace "and" with comma
                        .split(/[,]/)
                        .map(item => item.trim())
                        .map(item => item.replace(/^(a |an )/i, '')) // Remove "a" or "an" prefix
                        .filter(item => item.length > 0)
                        .filter(item => !['a', 'an'].includes(item.toLowerCase())); // Filter out standalone "a" or "an"
                    
                    if (items.length > 0) {
                        if (waitingForSellItems) {
                            waitingForSellItems = false;
                            showShopItemButtons(items, 'sell');
                        } else if (waitingForAppraiseItems) {
                            waitingForAppraiseItems = false;
                            showShopItemButtons(items, 'appraise');
                        }
                    }
                }
            }
        }

        function showShopItemButtons(items, action) {
            const title = action === 'buy' ? 'Buy Item' : action === 'sell' ? 'Sell Item' : 'Appraise Item';
            showPopup(title, items, (item) => {
                sendCommand(action + ' ' + item);
            });
        }

        function checkForSpellRefresh() {
            // Look for "Cast WHAT spell?" to trigger spell refresh
            if (recentTerminalText.includes('Cast WHAT spell?')) {
                waitingForSpellRefresh = false;
                currentSpells = []; // Clear old spells
                waitingForSpells = true;
                sendCommand('spells');
            }
        }

        function checkForItemDrops(text) {
            // Look for pattern: "<item> falls to the ground!"
            const regex = /(.+?)\s+falls to the ground!/gi;
            const matches = [...text.matchAll(regex)];
            
            if (matches.length > 0) {
                // Get the last match (most recent drop)
                const lastMatch = matches[matches.length - 1];
                let item = lastMatch[1].trim();
                
                // Remove "a" or "an" prefix
                item = item.replace(/^(a |an )/i, '');
                
                console.log('Item dropped:', item);
                
                // Auto-get the item
                setTimeout(() => {
                    sendCommand('get ' + item);
                }, 100);
            }
            
            // Check for spell level up
            if (text.includes('The god smiles at you in approval')) {
                console.log('Spell level up detected!');
                // Refresh spell list
                currentSpells = [];
                waitingForSpells = true;
                setTimeout(() => {
                    sendCommand('spells');
                }, 100);
            }
        }

        function extractPotions() {
            // Look for "You are holding" - use lastIndexOf to find the most recent occurrence
            const searchText = 'You are holding';
            const lastIndex = recentTerminalText.lastIndexOf(searchText);
            
            if (lastIndex !== -1) {
                // Extract text after "You are holding"
                const afterText = recentTerminalText.substring(lastIndex + searchText.length);
                
                // Take until newline or period
                const match = afterText.match(/^([^\n.]+)/);
                
                if (match) {
                    const itemString = match[1];
                    console.log('Inventory string found:', itemString);
                    
                    // Split by commas and "and", then clean up
                    const items = itemString
                        .replace(/\s+and\s+/gi, ',') // Replace "and" with comma
                        .split(/[,]/)
                        .map(item => item.trim())
                        .map(item => item.replace(/^(a |an )/i, '')) // Remove "a" or "an" prefix
                        .filter(item => item.length > 0);
                    
                    // Filter only items ending with "potion"
                    const potions = items.filter(item => {
                        const lower = item.toLowerCase();
                        return lower.endsWith('potion') || lower.includes('potion');
                    });
                    
                    waitingForPotions = false;
                    console.log('Potions found:', potions);
                    
                    if (potions.length > 0) {
                        currentPotions = potions;
                        showPopup('Select Potion', potions, (potion) => {
                            sendCommand('drink ' + potion);
                        });
                    } else {
                        // No potions, just send DRINK
                        currentPotions = [];
                        sendCommand('drink');
                    }
                }
            }
        }

        function extractExits() {
            // Look for "Visible exits are:" - use lastIndexOf to find the most recent occurrence
            const searchText = 'Visible exits are:';
            const lastIndex = recentTerminalText.lastIndexOf(searchText);
            
            if (lastIndex !== -1) {
                // Extract text after "Visible exits are:"
                const afterText = recentTerminalText.substring(lastIndex + searchText.length);
                
                // Take until newline or period
                const match = afterText.match(/^([^\n.]+)/);
                
                if (match) {
                    const exitString = match[1];
                    console.log('Exit string found:', exitString);
                    
                    // Split by commas and remove "and"
                    const exits = exitString
                        .toLowerCase()
                        .replace(/\band\b/g, '')
                        .split(/[,\s]+/)
                        .map(e => e.trim())
                        .filter(e => e.length > 0 && e !== '');
                    
                    waitingForExits = false;
                    console.log('Exits parsed:', exits);
                    updateNavButtons(exits);
                }
            }
        }

        function updateNavButtons(availableExits) {
            // Disable all nav buttons first
            const navButtons = ['btnN', 'btnS', 'btnE', 'btnW', 'btnU', 'btnD'];
            const directionMap = {
                'n': 'btnN', 'north': 'btnN',
                's': 'btnS', 'south': 'btnS',
                'e': 'btnE', 'east': 'btnE',
                'w': 'btnW', 'west': 'btnW',
                'u': 'btnU', 'up': 'btnU',
                'd': 'btnD', 'down': 'btnD'
            };
            
            // Disable all buttons
            navButtons.forEach(btnId => {
                const btn = document.getElementById(btnId);
                if (btn) btn.disabled = true;
            });
            
            // Enable only available exits
            availableExits.forEach(exit => {
                const btnId = directionMap[exit];
                if (btnId) {
                    const btn = document.getElementById(btnId);
                    if (btn) btn.disabled = false;
                }
            });
        }

        function enableAllNavButtons() {
            const navButtons = ['btnN', 'btnS', 'btnE', 'btnW', 'btnU', 'btnD'];
            navButtons.forEach(btnId => {
                const btn = document.getElementById(btnId);
                if (btn) btn.disabled = false;
            });
        }

        function updateTargets() {
            const targets = extractTargets(recentTerminalText);
            
            if (targets.length > 0) {
                currentTargets = targets;
                console.log('Targets found:', targets);
            }
        }

        function handleHitButton() {
            if (currentTargets.length > 0) {
                showPopup('Select Target', currentTargets, (target) => {
                    sendCommand('hit ' + target);
                    setTimeout(() => sendCommand('hits'), 100);
                });
            } else {
                sendCommand('hit');
            }
        }

        function handleCastButton() {
            if (currentSpells.length > 0) {
                showPopup('Select Spell', currentSpells, (spell) => {
                    selectedSpell = spell;
                    if (currentTargets.length > 0) {
                        showPopup('Select Target', currentTargets, (target) => {
                            sendCommand('cast ' + selectedSpell + ' ' + target);
                            selectedSpell = null;
                            waitingForSpellRefresh = true;
                            setTimeout(() => sendCommand('hits'), 100);
                        });
                    } else {
                        sendCommand('cast ' + selectedSpell);
                        selectedSpell = null;
                    }
                });
            } else {
                waitingForSpells = true;
                sendCommand('spells');
            }
        }

        function handleDrinkButton() {
            waitingForPotions = true;
            sendCommand('i');
        }

        function handleHelpButton() {
            const topics = [
                'Air', 'Attributes', 'Combat', 'Commands', 'Credits',
                'Earth', 'Elements', 'Experience', 'Fire', 'Gold',
                'Hints', 'Invoking', 'Items', 'Magic', 'Movement',
                'Speed', 'Starting', 'Talismans', 'Water'
            ];
            showPopup('Help Topics', topics, (topic) => {
                sendCommand('help ' + topic);
            });
        }

        function handleSocialButton() {
            const actions = [
                'Bow', 'Blush', 'Burp', 'Chortle', 'Cry', 'Frown',
                'Glare', 'Grin', 'Grumble', 'Hug', 'Kick', 'Kiss',
                'Laugh', 'Nod', 'Smack', 'Smile', 'Smooch', 'Snarl', 'Wave'
            ];
            showPopup('Social Actions', actions, (action) => {
                sendCommand(action);
            });
        }

        function handleShopButton() {
            const actions = ['Buy', 'Sell', 'Appraise'];
            showPopup('Shop', actions, (action) => {
                handleShopAction(action);
            });
        }

        function sendCurrentInput() {
            const input = document.getElementById('commandInput');
            const command = input.value.trim();
            
            if (command) {
                sendCommand(command);
                input.value = '';
            } else {
                // Send just ENTER if input is empty
                sendCommand('');
            }
            input.focus();
        }

        function handleEnter(event) {
            if (event.key === 'Enter') {
                sendCurrentInput();
            }
        }
    </script>
</body>
</html>
