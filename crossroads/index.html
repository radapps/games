<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>BBS Terminal</title>
    <link href="https://fonts.googleapis.com/css2?family=VT323&family=IBM+Plex+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --accent-primary: #58a6ff;
            --accent-secondary: #79c0ff;
            --accent-success: #3fb950;
            --accent-warning: #d29922;
            --accent-danger: #f85149;
            --text-primary: #c9d1d9;
            --text-secondary: #8b949e;
            --border-default: #30363d;
            --border-muted: #21262d;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'IBM Plex Mono', monospace;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
        }

        .container {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Login Panel */
        .login-panel {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .login-panel.hidden {
            display: none;
        }

        .login-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-default);
            border-radius: 12px;
            padding: 32px;
            width: 100%;
            max-width: 480px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
        }

        .login-card h2 {
            font-size: 1.5em;
            margin-bottom: 8px;
            color: var(--text-primary);
        }

        .login-card p {
            color: var(--text-secondary);
            margin-bottom: 24px;
            font-size: 0.9em;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            color: var(--text-secondary);
            font-size: 0.85em;
            font-weight: 500;
        }

        .form-group input {
            width: 100%;
            padding: 10px 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-default);
            border-radius: 6px;
            color: var(--text-primary);
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.9em;
            transition: all 0.2s ease;
        }

        .form-group input:focus {
            outline: none;
            border-color: var(--accent-primary);
            background: var(--bg-secondary);
        }

        .connect-btn {
            width: 100%;
            padding: 12px;
            background: var(--accent-primary);
            border: none;
            border-radius: 6px;
            color: #ffffff;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.95em;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .connect-btn:hover {
            background: var(--accent-secondary);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(88, 166, 255, 0.3);
        }

        .connect-btn:active {
            transform: translateY(0);
        }

        /* Main Content */
        .main-content {
            flex: 1;
            display: none;
            flex-direction: column;
            min-height: 0;
        }

        .main-content.active {
            display: flex;
        }

        /* Terminal - Top Half */
        .terminal-container {
            height: 55vh;
            display: flex;
            flex-direction: column;
            padding: 8px 8px 0 8px;
        }

        .terminal {
            flex: 1;
            background: #000000;
            border: 1px solid var(--border-default);
            border-radius: 8px;
            padding: 16px;
            overflow-y: auto;
            font-family: 'VT323', monospace;
            font-size: 1.2em;
            line-height: 1.3;
            color: #ffffff;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .terminal::-webkit-scrollbar {
            width: 10px;
        }

        .terminal::-webkit-scrollbar-track {
            background: #000000;
        }

        .terminal::-webkit-scrollbar-thumb {
            background: var(--border-default);
            border-radius: 5px;
        }

        .terminal::-webkit-scrollbar-thumb:hover {
            background: var(--text-secondary);
        }

        /* Bottom Controls Area */
        .controls-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 8px;
            gap: 4px;
            overflow-y: auto;
            min-height: 0;
        }

        .controls-area::-webkit-scrollbar {
            width: 8px;
        }

        .controls-area::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        .controls-area::-webkit-scrollbar-thumb {
            background: var(--border-default);
            border-radius: 4px;
        }

        .controls-area::-webkit-scrollbar-thumb:hover {
            background: var(--text-secondary);
        }

        /* Popup Modal for Button Lists */
        .popup-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .popup-overlay.active {
            display: flex;
        }

        .popup-container {
            background: var(--bg-secondary);
            border: 2px solid var(--accent-primary);
            border-radius: 8px;
            width: 90%;
            max-width: 400px;
            max-height: 70vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        .popup-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            border-bottom: 1px solid var(--border-default);
        }

        .popup-title {
            font-size: 1.1em;
            font-weight: 500;
            color: var(--accent-primary);
        }

        .popup-close {
            width: 32px;
            height: 32px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-default);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 1.2em;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .popup-close:hover {
            background: var(--accent-danger);
            border-color: var(--accent-danger);
            color: #ffffff;
        }

        .popup-content {
            padding: 16px;
            overflow-y: auto;
            flex: 1;
        }

        .popup-content::-webkit-scrollbar {
            width: 8px;
        }

        .popup-content::-webkit-scrollbar-track {
            background: var(--bg-tertiary);
        }

        .popup-content::-webkit-scrollbar-thumb {
            background: var(--border-default);
            border-radius: 4px;
        }

        .popup-content::-webkit-scrollbar-thumb:hover {
            background: var(--text-secondary);
        }

        .popup-button-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .popup-list-btn {
            padding: 12px 16px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-default);
            border-radius: 6px;
            color: var(--text-primary);
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: left;
        }

        .popup-list-btn:hover {
            background: var(--bg-primary);
            border-color: var(--accent-primary);
            transform: translateX(4px);
        }

        .popup-list-btn:active {
            transform: translateX(2px);
        }

        /* Map Image Popup */
        .map-image-container {
            max-width: 90vw;
            max-height: 80vh;
            overflow: auto;
            background: var(--bg-tertiary);
            border-radius: 8px;
            padding: 8px;
        }

        .map-image {
            display: block;
            width: 100%;
            height: auto;
            cursor: zoom-in;
            transition: transform 0.2s ease;
        }

        .map-image.zoomed {
            cursor: zoom-out;
            transform: scale(1.5);
            transform-origin: center;
        }

        @media (max-width: 768px) {
            .map-image.zoomed {
                transform: scale(2);
            }
        }

        /* Settings Controls */
        .settings-group {
            margin: 16px 0;
            padding: 16px;
            background: var(--bg-tertiary);
            border-radius: 6px;
        }

        .settings-label {
            display: block;
            font-size: 0.9em;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }

        .settings-toggle {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
        }

        .settings-toggle button {
            flex: 1;
            padding: 8px 16px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-default);
            border-radius: 4px;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .settings-toggle button.active {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
            color: #ffffff;
        }

        .settings-toggle button:hover:not(.active) {
            background: var(--bg-primary);
            border-color: var(--accent-primary);
        }

        .font-size-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .font-size-btn {
            width: 48px;
            height: 48px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-default);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 1.5em;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .font-size-btn:hover {
            background: var(--bg-primary);
            border-color: var(--accent-primary);
        }

        .font-size-display {
            flex: 1;
            text-align: center;
            font-size: 1em;
            color: var(--text-secondary);
        }

        /* Input Row */
        .input-row {
            display: flex;
            gap: 12px;
        }

        .input-wrapper {
            flex: 1;
            display: flex;
            gap: 8px;
        }

        .input-wrapper input {
            flex: 1;
            padding: 10px 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-default);
            border-radius: 6px;
            color: var(--text-primary);
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.9em;
        }

        .input-wrapper input:focus {
            outline: none;
            border-color: var(--accent-primary);
        }

        .send-btn {
            padding: 10px 20px;
            background: var(--accent-primary);
            border: none;
            border-radius: 6px;
            color: #ffffff;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.9em;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .send-btn:hover {
            background: var(--accent-secondary);
        }

        /* Button Rows */
        .buttons-row {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .all-buttons-container {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .button-row {
            display: flex;
            gap: 4px;
            justify-content: center;
            align-items: center;
        }

        .button-spacer {
            width: 48px;
            height: 48px;
        }

        .control-btn {
            padding: 4px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-default);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 1.6em;
            cursor: pointer;
            transition: all 0.15s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 48px;
            height: 48px;
        }

        .control-btn:hover:not(:disabled) {
            background: var(--bg-primary);
            border-color: var(--accent-primary);
            transform: scale(1.05);
        }

        .control-btn:active:not(:disabled) {
            transform: scale(0.95);
        }

        .control-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        /* Target buttons - hidden by default */
        .target-buttons {
            display: none;
            flex-direction: column;
            gap: 2px;
            margin-top: 2px;
            position: absolute;
            z-index: 100;
            min-width: 120px;
        }

        .target-buttons.active {
            display: flex;
        }

        .target-btn {
            padding: 4px 8px;
            background: var(--bg-tertiary);
            border: 1px solid var(--accent-warning);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 0.75em;
            cursor: pointer;
            transition: all 0.15s ease;
            text-align: left;
            white-space: nowrap;
        }

        .target-btn:hover {
            background: var(--bg-primary);
            border-color: var(--accent-primary);
        }

        /* Spell buttons */
        .spell-buttons {
            display: none;
            flex-direction: column;
            gap: 2px;
            margin-top: 2px;
            position: absolute;
            z-index: 100;
            min-width: 120px;
        }

        .spell-buttons.active {
            display: flex;
        }

        .spell-btn {
            padding: 4px 8px;
            background: var(--bg-tertiary);
            border: 1px solid var(--accent-primary);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 0.75em;
            cursor: pointer;
            transition: all 0.15s ease;
            text-align: left;
            white-space: nowrap;
        }

        .spell-btn:hover {
            background: var(--bg-primary);
            border-color: var(--accent-secondary);
        }

        /* Dynamic Buttons */
        .dynamic-section {
            display: none;
        }

        .dynamic-section.active {
            display: block;
        }

        .dynamic-btn {
            background: linear-gradient(135deg, rgba(255, 165, 0, 0.15), rgba(255, 215, 0, 0.15));
            border-color: var(--accent-warning);
        }

        .dynamic-btn:hover {
            background: linear-gradient(135deg, rgba(255, 165, 0, 0.25), rgba(255, 215, 0, 0.25));
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .terminal-container {
                height: 50vh;
            }

            .terminal {
                font-size: 0.7em;
            }

            .buttons-row {
                flex-direction: column;
                gap: 4px;
            }
        }

        @media (max-width: 600px) {
            .header {
                padding: 10px 12px;
            }

            .header-title h1 {
                font-size: 1.4em;
            }

            .login-card {
                padding: 24px;
            }

            .key-btn {
                min-width: 32px;
                height: 36px;
                font-size: 0.8em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Login Panel -->
        <div class="login-panel" id="loginPanel">
            <div class="login-card">
                <h2>Connect to BBS</h2>
                <p>Enter connection details and credentials</p>
                <div class="form-group">
                    <label for="wsUrl">WebSocket URL</label>
                    <input type="text" id="wsUrl" placeholder="wss://server.com/host/port" value="wss://unabruptly-multiplated-kory.ngrok-free.dev:443/192.168.40.69/23">
                </div>
                <div class="form-group">
                    <label for="username">Username</label>
                    <input type="text" id="username" placeholder="Your username">
                </div>
                <div class="form-group">
                    <label for="password">Password</label>
                    <input type="password" id="password" placeholder="Your password">
                </div>
                <div class="form-group" style="display: flex; align-items: center; gap: 8px;">
                    <input type="checkbox" id="newUser" style="width: auto; margin: 0;">
                    <label for="newUser" style="margin: 0; cursor: pointer;">New User (skip auto-login)</label>
                </div>
                <button class="connect-btn" onclick="connect()">Connect</button>
            </div>
        </div>

        <!-- Main Content -->
        <div class="main-content" id="mainContent">
            <!-- Terminal - Top Half -->
            <div class="terminal-container">
                <div class="terminal" id="terminal"></div>
            </div>

            <!-- Bottom Controls Area -->
            <div class="controls-area">
                <!-- Input Row -->
                <div class="input-row">
                    <div class="input-wrapper">
                        <input type="text" id="commandInput" placeholder="Type command..." onkeypress="handleEnter(event)">
                        <button class="send-btn" onclick="sendCurrentInput()">Send</button>
                    </div>
                </div>

                <!-- Buttons Row -->
                <div class="buttons-row">
                    <div class="all-buttons-container">
                        <!-- Row 1: HIT, CAST, DRINK, <empty>, LOOK, N, U -->
                        <div class="button-row">
                            <button class="control-btn" onclick="handleHitButton()" title="Hit">‚öîÔ∏è</button>
                            <button class="control-btn" onclick="handleCastButton()" title="Cast">üìñ</button>
                            <button class="control-btn" onclick="handleDrinkButton()" title="Drink">üíß</button>
                            <div class="button-spacer"></div>
                            <button class="control-btn" onclick="sendCommand('look')" title="Look">üëÅÔ∏è</button>
                            <button class="control-btn" id="btnN" onclick="sendDirectional('n')" title="North">‚¨ÜÔ∏è</button>
                            <button class="control-btn" id="btnU" onclick="sendDirectional('u')" title="Up">‚§¥Ô∏è</button>
                        </div>
                        
                        <!-- Row 2: I, EQUIP, HITS, <empty>, W, EX, E -->
                        <div class="button-row">
                            <button class="control-btn" onclick="sendCommand('i')" title="Inventory">üëú</button>
                            <button class="control-btn" onclick="handleEquipButton()" title="Equip">üõ°Ô∏è</button>
                            <button class="control-btn" onclick="sendCommand('hits')" title="HP/SP">‚ù§Ô∏è‚Äçü©π</button>
                            <div class="button-spacer"></div>
                            <button class="control-btn" id="btnW" onclick="sendDirectional('w')" title="West">‚¨ÖÔ∏è</button>
                            <button class="control-btn" onclick="handleExitsButton()" title="Exits">üö™</button>
                            <button class="control-btn" id="btnE" onclick="sendDirectional('e')" title="East">‚û°Ô∏è</button>
                        </div>
                        
                        <!-- Row 3: SHOP, SOCIAL, STATS, <empty>, MAP, S, D -->
                        <div class="button-row">
                            <button class="control-btn" onclick="handleShopButton()" title="Shop">üí≤</button>
                            <button class="control-btn" onclick="handleSocialButton()" title="Social">üòÄ</button>
                            <button class="control-btn" onclick="sendCommand('stats')" title="Stats">üìä</button>
                            <div class="button-spacer"></div>
                            <button class="control-btn" onclick="handleMapButton()" title="Map">üåé</button>
                            <button class="control-btn" id="btnS" onclick="sendDirectional('s')" title="South">‚¨áÔ∏è</button>
                            <button class="control-btn" id="btnD" onclick="sendDirectional('d')" title="Down">‚§µÔ∏è</button>
                        </div>

                        <!-- Row 4: HELP, SETTINGS, <empty>, <empty>, <empty>, <empty>, <empty> -->
                        <div class="button-row">
                            <button class="control-btn" onclick="handleHelpButton()" title="Help">‚ùì</button>
                            <button class="control-btn" onclick="handleSettingsButton()" title="Settings">‚öôÔ∏è</button>
                            <div class="button-spacer"></div>
                            <div class="button-spacer"></div>
                            <div class="button-spacer"></div>
                            <div class="button-spacer"></div>
                            <div class="button-spacer"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Popup Modal for Button Lists -->
    <div class="popup-overlay" id="popupOverlay" onclick="closePopupIfClickedOutside(event)">
        <div class="popup-container" onclick="event.stopPropagation()">
            <div class="popup-header">
                <div class="popup-title" id="popupTitle">Select</div>
                <button class="popup-close" onclick="closePopup()">‚úï</button>
            </div>
            <div class="popup-content">
                <div class="popup-button-list" id="popupButtonList"></div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let ws = null;
        let isConnected = false;
        let currentTerminalText = '';
        let recentTerminalText = '';
        let currentTargets = []; // Store current targets from "There is a ... here."
        let currentANSIStyle = ''; // Persist ANSI color state across chunks
        let currentSpells = []; // Store user's spells
        let selectedSpell = null; // Currently selected spell for casting
        let waitingForSpells = false; // Waiting for spell list from server
        let waitingForExits = false; // Waiting for exit list from server
        let currentPotions = []; // Store available potions
        let waitingForPotions = false; // Waiting for inventory to extract potions
        let waitingForSpellRefresh = false; // Waiting to check if CAST failed and needs spell list
        let waitingForShopItems = false; // Waiting for shop inventory
        let waitingForSellItems = false; // Waiting for sell inventory
        let waitingForAppraiseItems = false; // Waiting for appraise inventory
        let currentShopkeeper = null; // Current shopkeeper name
        let currentUsername = ''; // Logged-in username
        let waitingForArmItems = false; // Waiting for arm inventory
        let waitingForWearItems = false; // Waiting for wear inventory
        let terminalFontSize = 1.2; // Current terminal font size in em
        let descriptionMode = 'long'; // 'short' or 'long'
        let waitingForShopDetection = false; // Waiting to detect shopkeeper before showing shop menu
        let waitingForGoldCheck = false; // Waiting to check player gold before buying
        let playerGold = 0; // Current player gold
        let currentShopItems = []; // Items in shop with prices
        let waitingForTargetDetection = false; // Waiting for LOOK to detect targets
        let targetDetectionForSpell = false; // Track if target detection is for spell casting

        // Popup control functions
        function showPopup(title, buttons, onClickCallback) {
            const overlay = document.getElementById('popupOverlay');
            const titleEl = document.getElementById('popupTitle');
            const listEl = document.getElementById('popupButtonList');
            
            titleEl.textContent = title;
            listEl.innerHTML = '';
            
            buttons.forEach(button => {
                const btn = document.createElement('button');
                btn.className = 'popup-list-btn';
                btn.textContent = button.label || button;
                btn.onclick = () => {
                    const value = button.value || button;
                    closePopup();
                    // Call callback AFTER popup is closed to prevent race conditions
                    setTimeout(() => {
                        onClickCallback(value);
                    }, 50);
                };
                listEl.appendChild(btn);
            });
            
            overlay.classList.add('active');
        }

        function closePopup() {
            const overlay = document.getElementById('popupOverlay');
            overlay.classList.remove('active');
        }

        function closePopupIfClickedOutside(event) {
            if (event.target.id === 'popupOverlay') {
                closePopup();
            }
        }

        // Telnet IAC (Interpret As Command) constants
        const IAC = 255;  // 0xFF
        const DONT = 254; // 0xFE
        const DO = 253;   // 0xFD
        const WONT = 252; // 0xFC
        const WILL = 251; // 0xFB
        const SB = 250;   // 0xFA - Subnegotiation Begin
        const SE = 240;   // 0xF0 - Subnegotiation End

        // ANSI color map
        const ANSI_COLORS = {
            '0': 'color: #ffffff',      // Reset to white
            '30': 'color: #484f58',     // Black
            '31': 'color: #ff7b72',     // Red
            '32': 'color: #3fb950',     // Green
            '33': 'color: #d29922',     // Yellow
            '34': 'color: #58a6ff',     // Blue
            '35': 'color: #bc8cff',     // Magenta
            '36': 'color: #76e3ea',     // Cyan
            '37': 'color: #ffffff',     // White
            '90': 'color: #6e7681',     // Bright Black (Gray)
            '91': 'color: #ffa198',     // Bright Red
            '92': 'color: #56d364',     // Bright Green
            '93': 'color: #e3b341',     // Bright Yellow
            '94': 'color: #79c0ff',     // Bright Blue
            '95': 'color: #d2a8ff',     // Bright Magenta
            '96': 'color: #b3f0ff',     // Bright Cyan
            '97': 'color: #f0f6fc',     // Bright White
        };

        // Dynamic button rules
        // Load saved credentials
        window.addEventListener('DOMContentLoaded', () => {
            const saved = {
                wsUrl: localStorage.getItem('bbs_ws_url'),
                username: localStorage.getItem('bbs_username'),
                password: localStorage.getItem('bbs_password')
            };
            
            if (saved.wsUrl) document.getElementById('wsUrl').value = saved.wsUrl;
            if (saved.username) document.getElementById('username').value = saved.username;
            if (saved.password) document.getElementById('password').value = saved.password;
            
            // Load settings
            loadSettings();
        });

        function connect() {
            const wsUrl = document.getElementById('wsUrl').value.trim();
            const username = document.getElementById('username').value.trim();
            const password = document.getElementById('password').value.trim();
            const isNewUser = document.getElementById('newUser').checked;

            if (!wsUrl) {
                alert('Please enter a WebSocket URL');
                return;
            }

            // Save credentials and username
            localStorage.setItem('bbs_ws_url', wsUrl);
            localStorage.setItem('bbs_username', username);
            localStorage.setItem('bbs_password', password);
            currentUsername = username; // Store for self-targeting spells

            // Hide login, show terminal
            document.getElementById('loginPanel').classList.add('hidden');
            document.getElementById('mainContent').classList.add('active');

            // Clear terminal
            document.getElementById('terminal').innerHTML = '';
            currentTerminalText = '';
            recentTerminalText = '';

            appendToTerminal('Connecting to ' + wsUrl + '...\n');

            try {
                ws = new WebSocket(wsUrl);
                ws.binaryType = 'arraybuffer';  // Important for binary telnet data!

                ws.onopen = function() {
                    isConnected = true;
                    appendToTerminal('‚úì Connected!\n\n');
                    
                    // Auto-login sequence (skip if new user checkbox is checked)
                    if (!isNewUser && username && password) {
                        setTimeout(() => sendCommand(username), 3000);
                        setTimeout(() => sendCommand(password), 3100);
                        setTimeout(() => sendCommand('q'), 3600);  // 500ms after password
                        setTimeout(() => sendCommand('g'), 3800);  // 200ms after Q
                        setTimeout(() => sendCommand('q'), 4000);  // 200ms after G
                        setTimeout(() => sendCommand('5'), 4200);  // 200ms after Q
                        setTimeout(() => sendCommand('p'), 4400);  // 200ms after 5
                    }
                };

                ws.onmessage = function(event) {
                    let data;
                    
                    // Handle binary data
                    if (event.data instanceof ArrayBuffer) {
                        const bytes = new Uint8Array(event.data);
                        const filtered = filterTelnetIAC(bytes);
                        data = new TextDecoder('utf-8').decode(filtered);
                    } else {
                        data = event.data;
                    }

                    if (data.length > 0) {
                        appendToTerminal(data);
                        
                        // Store text for dynamic buttons and target extraction
                        const plainText = stripANSI(data);
                        currentTerminalText += plainText;
                        recentTerminalText += plainText;
                        
                        // Keep buffers manageable
                        if (currentTerminalText.length > 10000) {
                            currentTerminalText = currentTerminalText.slice(-10000);
                        }
                        if (recentTerminalText.length > 1000) {
                            recentTerminalText = recentTerminalText.slice(-1000);
                        }
                        
                        // Extract targets from recent text
                        updateTargets();
                        
                        // Extract spells if waiting for them
                        if (waitingForSpells) {
                            extractSpells();
                        }
                        
                        // Extract exits if waiting for them
                        if (waitingForExits) {
                            extractExits();
                        }
                        
                        // Extract potions if waiting for them
                        if (waitingForPotions) {
                            extractPotions();
                        }
                        
                        // Check for spell refresh needed
                        if (waitingForSpellRefresh) {
                            checkForSpellRefresh();
                        }
                        
                        // Check for item drops
                        checkForItemDrops(plainText);
                        
                        // Extract shop items if waiting
                        if (waitingForShopItems) {
                            extractShopItems();
                        }
                        
                        // Extract sell/appraise items if waiting
                        if (waitingForSellItems || waitingForAppraiseItems) {
                            extractInventoryForShop();
                        }
                        
                        // Extract arm/wear items if waiting
                        if (waitingForArmItems || waitingForWearItems) {
                            extractInventoryForEquip();
                        }
                        
                        // Check for shopkeeper detection
                        if (waitingForShopDetection) {
                            checkForShopkeeper();
                        }
                        
                        // Check for gold amount
                        if (waitingForGoldCheck) {
                            extractPlayerGold();
                        }
                        
                        // Check for target detection
                        if (waitingForTargetDetection) {
                            detectTargetsFromLook();
                        }
                    }
                };

                ws.onerror = function(error) {
                    console.error('WebSocket error:', error);
                    isConnected = false;
                    appendToTerminal('\n‚úó Connection error\n');
                };

                ws.onclose = function(event) {
                    console.log('WebSocket closed:', event.code, event.reason);
                    isConnected = false;
                    appendToTerminal('\n[Connection closed]\n');
                };
            } catch (e) {
                appendToTerminal('\n‚úó Error: ' + e.message + '\n');
            }
        }

        function filterTelnetIAC(bytes) {
            const filtered = [];
            let i = 0;

            while (i < bytes.length) {
                if (bytes[i] === IAC) {
                    // Check for IAC IAC (escaped 255)
                    if (i + 1 < bytes.length && bytes[i + 1] === IAC) {
                        filtered.push(IAC);
                        i += 2;
                        continue;
                    }

                    // Handle IAC commands
                    if (i + 2 < bytes.length) {
                        const cmd = bytes[i + 1];
                        
                        // Check for subnegotiation
                        if (cmd === SB) {
                            // Skip until SE
                            i += 2;
                            while (i < bytes.length && !(bytes[i] === IAC && i + 1 < bytes.length && bytes[i + 1] === SE)) {
                                i++;
                            }
                            i += 2; // Skip IAC SE
                            continue;
                        }
                        
                        // Skip DO, DONT, WILL, WONT commands (3 bytes)
                        if (cmd === DO || cmd === DONT || cmd === WILL || cmd === WONT) {
                            i += 3;
                            continue;
                        }
                    }
                    
                    i++;
                } else {
                    filtered.push(bytes[i]);
                    i++;
                }
            }

            return new Uint8Array(filtered);
        }

        function appendToTerminal(text) {
            const terminal = document.getElementById('terminal');
            const processed = processANSI(text);
            terminal.innerHTML += processed;
            terminal.scrollTop = terminal.scrollHeight;
        }

        function stripANSI(text) {
            return text.replace(/\x1b\[[0-9;]*m/g, '').replace(/\x1b\[.*?[@-~]/g, '');
        }

        function processANSI(text) {
            // XP table for level progression
            const xpTable = [
                0, 121, 301, 587, 1082, 1866, 3180, 5251, 8674, 14042,
                22826, 36551, 58772, 93324, 148854, 234910, 372322, 584686,
                921970, 1441931, 2264012, 3528732, 5520666, 8579686, 13381636,
                20744626, 32269282, 49916387, 77467454, 119604354
            ];
            
            // Process Experience line to show next level XP
            text = text.replace(/Experience\s+:\s+(\d+)/g, (match, currentXP) => {
                const xp = parseInt(currentXP.replace(/,/g, ''));
                
                // Find next level XP
                let nextLevelXP = null;
                for (let i = 0; i < xpTable.length; i++) {
                    if (xpTable[i] > xp) {
                        nextLevelXP = xpTable[i];
                        break;
                    }
                }
                
                if (nextLevelXP !== null) {
                    // Format with commas
                    const formattedNextXP = nextLevelXP.toLocaleString();
                    return `Experience  : ${currentXP} / ${formattedNextXP}`;
                } else {
                    // Max level reached
                    return match;
                }
            });
            
            // Apply color rules based on line endings BEFORE HTML escaping
            // Split by any line ending (CRLF, CR, or LF)
            const lines = text.split(/\r\n|\r|\n/);
            const coloredLines = [];
            
            for (let i = 0; i < lines.length; i++) {
                let line = lines[i];
                const trimmedLine = line.trim();
                
                // Skip empty lines
                if (!trimmedLine) {
                    coloredLines.push(line);
                    continue;
                }
                
                // Check line endings and wrap with color markers
                let colorCode = null;
                if (trimmedLine.endsWith('points!')) {
                    colorCode = '#d29922';
                } else if (trimmedLine.endsWith('black smoke!')) {
                    colorCode = '#3fb950';
                } else if (trimmedLine.endsWith('but misses!')) {
                    colorCode = '#ffffff';
                } else if (trimmedLine.endsWith('you!')) {
                    colorCode = '#ff4444';
                } else if (trimmedLine.endsWith('falls to the ground!')) {
                    colorCode = '#bc8cff';
                } else if (trimmedLine.includes('The spell fizzled!')) {
                    colorCode = '#ff4444';
                }
                
                if (colorCode) {
                    line = `\x1b[COLOR:${colorCode}]${line}\x1b[COLOREND]`;
                }
                
                coloredLines.push(line);
            }
            text = coloredLines.join('\n');
            
            // Escape HTML
            text = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

            // Process ANSI escape codes and our color markers
            const regex = /\x1b\[([0-9;]*)m|\x1b\[COLOR:(#[0-9a-fA-F]{6})\]|\x1b\[COLOREND\]/g;
            let result = '';
            let lastIndex = 0;
            let customColor = null;

            text.replace(regex, (match, codes, color, offset) => {
                // Add text before this code
                if (offset > lastIndex) {
                    const textBefore = text.substring(lastIndex, offset);
                    let style = customColor || currentANSIStyle;
                    if (style) {
                        if (style.startsWith('#')) {
                            result += `<span style="color: ${style}">${textBefore}</span>`;
                        } else {
                            result += `<span style="${style}">${textBefore}</span>`;
                        }
                    } else {
                        result += textBefore;
                    }
                }

                // Handle our custom color markers
                if (color) {
                    customColor = color;
                } else if (match === '\x1b[COLOREND]') {
                    customColor = null;
                } else if (codes !== undefined) {
                    // Update ANSI style based on codes
                    const codeList = codes.split(';').filter(c => c);
                    for (const code of codeList) {
                        if (ANSI_COLORS[code]) {
                            currentANSIStyle = ANSI_COLORS[code];
                        } else if (code === '0' || code === '') {
                            currentANSIStyle = 'color: #ffffff'; // Reset to white
                        }
                    }
                }

                lastIndex = offset + match.length;
                return '';
            });

            // Add remaining text with current style
            if (lastIndex < text.length) {
                const textAfter = text.substring(lastIndex);
                let style = customColor || currentANSIStyle;
                if (style) {
                    if (style.startsWith('#')) {
                        result += `<span style="color: ${style}">${textAfter}</span>`;
                    } else {
                        result += `<span style="${style}">${textAfter}</span>`;
                    }
                } else {
                    result += textAfter;
                }
            }

            return result;
        }

        function sendCommand(command) {
            if (!isConnected || !ws || ws.readyState !== WebSocket.OPEN) {
                alert('Not connected');
                return;
            }

            try {
                // Send as binary (Uint8Array) instead of text
                const encoder = new TextEncoder();
                const data = encoder.encode(command + '\r\n');
                ws.send(data.buffer);
            } catch (e) {
                console.error('Send error:', e);
            }
        }

        function sendDirectional(direction) {
            // Clear targets when moving
            currentTargets = [];
            
            // Re-enable all nav buttons when moving
            enableAllNavButtons();
            
            // Send the directional command
            sendCommand(direction);
            
            // Auto-trigger exits check after a short delay
            setTimeout(() => {
                handleExitsButton();
            }, 500);
        }

        function handleExitsButton() {
            // Request exits from server
            waitingForExits = true;
            sendCommand('ex');
        }

        function extractTargets(text) {
            // First find the last occurrence of "...You" to get the most recent room description
            const youIndex = text.lastIndexOf('...You');
            
            // If "...You" is found, only look for targets after that point
            const searchText = youIndex !== -1 ? text.substring(youIndex) : text;
            
            // Look for pattern: "There is a ... here."
            const regex = /There is (?:a |an )?(.*?) here\./gi;
            const matches = [...searchText.matchAll(regex)];
            
            if (matches.length > 0) {
                // Get the last match (most recent)
                const lastMatch = matches[matches.length - 1];
                const targetString = lastMatch[1];
                
                // Split by "and" and commas to get individual targets
                const targets = targetString
                    .split(/(?:\s+and\s+|,\s*)/)
                    .map(t => t.trim())
                    .map(t => t.replace(/^(a |an )/i, '')) // Remove "a" or "an" prefix
                        .map(item => item.replace(/^suit of /i, '')) // Remove "suit of" prefix
                    .filter(t => t.length > 0);
                
                return targets;
            }
            
            return [];
        }

        function extractSpells() {
            // Look for "You have the ability to cast:" followed by spell names
            const regex = /You have the ability to cast:\s*([^\n]+)/i;
            const match = recentTerminalText.match(regex);
            
            if (match) {
                const spellString = match[1];
                // Split by spaces and/or tabs
                const spells = spellString
                    .split(/[\s\t]+/)
                    .map(s => s.trim())
                    .filter(s => s.length > 0);
                
                if (spells.length > 0) {
                    currentSpells = spells;
                    waitingForSpells = false;
                    console.log('Spells found:', spells);
                    // Auto-show spell list in popup
                    showPopup('Select Spell', currentSpells, (spell) => {
                        selectedSpell = spell;
                        if (currentTargets.length > 0) {
                            showPopup('Select Target', currentTargets, (target) => {
                                sendCommand('cast ' + selectedSpell + ' ' + target);
                                selectedSpell = null;
                                waitingForSpellRefresh = true;
                                setTimeout(() => sendCommand('hits'), 100);
                            });
                        } else {
                            sendCommand('cast ' + selectedSpell);
                            selectedSpell = null;
                        }
                    });
                }
            }
        }

        function handleShopAction(action) {
            if (action === 'Buy') {
                // Check player gold first, then look at shopkeeper
                waitingForGoldCheck = true;
                sendCommand('i');
            } else if (action === 'Sell') {
                waitingForSellItems = true;
                sendCommand('i');
            } else if (action === 'Appraise') {
                waitingForAppraiseItems = true;
                sendCommand('i');
            }
        }

        function findShopkeeper() {
            // Known shopkeeper names
            const shopkeeperNames = [
                'monk', 'Oria', 'Zell', 'Hanrod', 'Wenzel', 'Izalig',
                'Amaranth', 'Klemm', 'Hebezega', 'Black', 'Lor', 'Dara',
                'Marna', 'Arond', 'Jomb', 'Mokkis', 'Roltima'
            ];
            
            // Find last occurrence of "here."
            const lastIndex = recentTerminalText.lastIndexOf('here.');
            
            if (lastIndex !== -1) {
                // Get text before "here." to find the sentence
                const beforeText = recentTerminalText.substring(0, lastIndex);
                
                // Find the start of this sentence (look for previous period or start of text)
                const lastPeriod = beforeText.lastIndexOf('.');
                const sentenceStart = lastPeriod !== -1 ? lastPeriod + 1 : 0;
                const sentence = recentTerminalText.substring(sentenceStart, lastIndex + 5); // Include "here."
                
                console.log('Shopkeeper search - sentence:', sentence);
                
                // Check if any shopkeeper name is in this sentence
                for (const name of shopkeeperNames) {
                    if (sentence.includes(name)) {
                        console.log('Found shopkeeper:', name);
                        return name;
                    }
                }
            }
            
            console.log('No shopkeeper found');
            return null;
        }

        function detectTargetsFromLook() {
            waitingForTargetDetection = false;
            
            // Extract targets from the recent LOOK output
            currentTargets = extractTargets(recentTerminalText);
            
            if (targetDetectionForSpell) {
                // Show spell selection, which will then show targets
                showPopup('Select Spell', currentSpells, (spell) => {
                    selectedSpell = spell;
                    console.log('Spell selected:', selectedSpell);
                    
                    // Show targets including "(no target)" for self-casting
                    const targets = [...currentTargets];
                    targets.push('(no target)'); // Always add no-target option
                    
                    console.log('Showing targets:', targets);
                    showTargetPopup(targets, (target) => {
                        console.log('Target selected:', target);
                        if (target === '(no target)') {
                            // Cast without target (game defaults to self)
                            sendCommand('cast ' + selectedSpell);
                        } else {
                            sendCommand('cast ' + selectedSpell + ' ' + target);
                        }
                        selectedSpell = null;
                        waitingForSpellRefresh = true;
                        setTimeout(() => sendCommand('hits'), 100);
                    });
                });
            } else {
                // Show targets for HIT
                if (currentTargets.length > 0) {
                    showTargetPopup(currentTargets, (target) => {
                        sendCommand('hit ' + target);
                        setTimeout(() => sendCommand('hits'), 100);
                    });
                } else {
                    sendCommand('hit');
                }
            }
        }

        function showTargetPopup(targets, onClickCallback) {
            const overlay = document.getElementById('popupOverlay');
            const titleEl = document.getElementById('popupTitle');
            const listEl = document.getElementById('popupButtonList');
            
            titleEl.textContent = 'Select Target';
            listEl.innerHTML = '';
            
            targets.forEach(target => {
                const btn = document.createElement('button');
                btn.className = 'popup-list-btn';
                btn.textContent = target;
                
                // Color targets in red except for "(no target)"
                if (target !== '(no target)') {
                    btn.style.color = '#ff4444';
                }
                
                btn.onclick = () => {
                    closePopup();
                    setTimeout(() => {
                        onClickCallback(target);
                    }, 50);
                };
                listEl.appendChild(btn);
            });
            
            overlay.classList.add('active');
        }

        function checkForShopkeeper() {
            waitingForShopDetection = false;
            const shopkeeper = findShopkeeper();
            
            if (shopkeeper) {
                currentShopkeeper = shopkeeper;
                // Show shop menu
                const actions = ['Buy', 'Sell', 'Appraise'];
                showPopup('Shop', actions, (action) => {
                    handleShopAction(action);
                });
            } else {
                alert('No shopkeeper found in this room');
            }
        }

        function extractPlayerGold() {
            // Look for "You have X gold pieces."
            const match = recentTerminalText.match(/You have (\d+) gold piece/i);
            
            if (match) {
                playerGold = parseInt(match[1]);
                console.log('Player gold:', playerGold);
                waitingForGoldCheck = false;
                
                // Now look at shopkeeper to get shop items
                if (currentShopkeeper) {
                    waitingForShopItems = true;
                    sendCommand('look ' + currentShopkeeper);
                }
            }
        }

        function showShopItemsWithPrices() {
            const overlay = document.getElementById('popupOverlay');
            const titleEl = document.getElementById('popupTitle');
            const listEl = document.getElementById('popupButtonList');
            
            // Create header showing player gold
            titleEl.innerHTML = `Buy Items - Gold: <span style="color: gold">${playerGold}</span>`;
            
            listEl.innerHTML = '';
            
            currentShopItems.forEach(item => {
                const canAfford = playerGold >= item.price;
                const btn = document.createElement('button');
                btn.className = 'popup-list-btn';
                btn.style.display = 'flex';
                btn.style.justifyContent = 'space-between';
                btn.style.alignItems = 'center';
                
                // Create name span
                const nameSpan = document.createElement('span');
                nameSpan.textContent = item.name;
                if (!canAfford) {
                    nameSpan.style.color = '#ff4444'; // Red for unaffordable
                }
                
                // Create price span
                const priceSpan = document.createElement('span');
                priceSpan.textContent = item.price + 'g';
                priceSpan.style.color = 'gold';
                priceSpan.style.marginLeft = '16px';
                
                btn.appendChild(nameSpan);
                btn.appendChild(priceSpan);
                
                if (canAfford) {
                    btn.onclick = () => {
                        sendCommand('buy ' + item.name);
                        closePopup();
                    };
                } else {
                    btn.style.opacity = '0.5';
                    btn.style.cursor = 'not-allowed';
                }
                
                listEl.appendChild(btn);
            });
            
            overlay.classList.add('active');
        }

        function extractShopItems() {
            // Look for shop inventory format: "Qty  Price  <item>"
            const lines = recentTerminalText.split('\n');
            const items = [];
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                // Match lines with numbers (qty and price) followed by item name
                const match = line.match(/^\d+\s+(\d+)\s+(.+)$/);
                if (match) {
                    items.push({
                        name: match[2].trim(),
                        price: parseInt(match[1])
                    });
                }
            }
            
            if (items.length > 0) {
                waitingForShopItems = false;
                currentShopItems = items;
                // Gold check already done, show items
                showShopItemsWithPrices();
            }
        }

        function extractInventoryForShop() {
            // Look for "You are holding" - use lastIndexOf to find the most recent occurrence
            const searchText = 'You are holding';
            const lastIndex = recentTerminalText.lastIndexOf(searchText);
            
            if (lastIndex !== -1) {
                // Extract text after "You are holding"
                const afterText = recentTerminalText.substring(lastIndex + searchText.length);
                
                // Take until period (including newlines)
                const match = afterText.match(/^([\s\S]+?)\./);
                
                if (match) {
                    const itemString = match[1];
                    
                    // Split by commas and "and", then clean up
                    const items = itemString
                        .replace(/\s+and\s+/gi, ',') // Replace "and" with comma
                        .split(/[,]/)
                        .map(item => item.trim())
                        .map(item => item.replace(/^(a |an )/i, '')) // Remove "a" or "an" prefix
                        .map(item => item.replace(/^suit of /i, '')) // Remove "suit of" prefix
                        .filter(item => item.length > 0)
                        .filter(item => !['a', 'an'].includes(item.toLowerCase())); // Filter out standalone "a" or "an"
                    
                    if (items.length > 0) {
                        if (waitingForSellItems) {
                            waitingForSellItems = false;
                            showShopItemButtons(items, 'sell');
                        } else if (waitingForAppraiseItems) {
                            waitingForAppraiseItems = false;
                            showShopItemButtons(items, 'appraise');
                        }
                    }
                }
            }
        }

        function extractInventoryForEquip() {
            // Look for "You are holding" - use lastIndexOf to find the most recent occurrence
            const searchText = 'You are holding';
            const lastIndex = recentTerminalText.lastIndexOf(searchText);
            
            console.log('Equip: Looking for inventory, lastIndex:', lastIndex);
            console.log('Equip: Recent text length:', recentTerminalText.length);
            
            if (lastIndex !== -1) {
                // Extract text after "You are holding"
                const afterText = recentTerminalText.substring(lastIndex + searchText.length);
                
                // Take until period (including newlines)
                const match = afterText.match(/^([\s\S]+?)\./);
                
                if (match) {
                    const itemString = match[1];
                    console.log('Equip: Raw item string:', itemString);
                    
                    // Split by commas and "and", then clean up
                    const items = itemString
                        .replace(/\s+and\s+/gi, ',') // Replace "and" with comma
                        .split(/[,]/)
                        .map(item => item.trim())
                        .map(item => item.replace(/^(a |an )/i, '')) // Remove "a" or "an" prefix
                        .map(item => item.replace(/^suit of /i, '')) // Remove "suit of" prefix
                        .filter(item => item.length > 0)
                        .filter(item => !['a', 'an'].includes(item.toLowerCase())); // Filter out standalone "a" or "an"
                    
                    console.log('Equip: Parsed items:', items);
                    
                    if (items.length > 0) {
                        if (waitingForArmItems) {
                            waitingForArmItems = false;
                            showEquipItemButtons(items, 'arm');
                        } else if (waitingForWearItems) {
                            waitingForWearItems = false;
                            showEquipItemButtons(items, 'wear');
                        }
                    }
                }
            }
        }

        function showEquipItemButtons(items, action) {
            const title = action === 'arm' ? 'Arm Item' : 'Wear Item';
            showPopup(title, items, (item) => {
                sendCommand(action + ' ' + item);
            });
        }

        function showShopItemButtons(items, action) {
            const title = action === 'buy' ? 'Buy Item' : action === 'sell' ? 'Sell Item' : 'Appraise Item';
            showPopup(title, items, (item) => {
                sendCommand(action + ' ' + item);
            });
        }

        function checkForSpellRefresh() {
            // Look for "Cast WHAT spell?" to trigger spell refresh
            if (recentTerminalText.includes('Cast WHAT spell?')) {
                waitingForSpellRefresh = false;
                currentSpells = []; // Clear old spells
                waitingForSpells = true;
                sendCommand('spells');
            }
        }

        function checkForItemDrops(text) {
            // Look for pattern: "<item> falls to the ground!"
            const regex = /(.+?)\s+falls to the ground!/gi;
            const matches = [...text.matchAll(regex)];
            
            if (matches.length > 0) {
                // Get the last match (most recent drop)
                const lastMatch = matches[matches.length - 1];
                let item = lastMatch[1].trim();
                
                // Remove "a" or "an" prefix
                item = item.replace(/^(a |an )/i, '');
                
                console.log('Item dropped:', item);
                
                // Auto-get the item
                setTimeout(() => {
                    sendCommand('get ' + item);
                }, 100);
            }
            
            // Check for spell level up
            if (text.includes('The god smiles at you in approval')) {
                console.log('Spell level up detected!');
                // Refresh spell list
                currentSpells = [];
                waitingForSpells = true;
                setTimeout(() => {
                    sendCommand('spells');
                }, 100);
            }
        }

        function extractPotions() {
            // Look for "You are holding" - use lastIndexOf to find the most recent occurrence
            const searchText = 'You are holding';
            const lastIndex = recentTerminalText.lastIndexOf(searchText);
            
            if (lastIndex !== -1) {
                // Extract text after "You are holding"
                const afterText = recentTerminalText.substring(lastIndex + searchText.length);
                
                // Take until period (including newlines)
                const match = afterText.match(/^([\s\S]+?)\./);
                
                if (match) {
                    const itemString = match[1];
                    console.log('Inventory string found:', itemString);
                    
                    // Split by commas and "and", then clean up
                    const items = itemString
                        .replace(/\s+and\s+/gi, ',') // Replace "and" with comma
                        .split(/[,]/)
                        .map(item => item.trim())
                        .map(item => item.replace(/^(a |an )/i, '')) // Remove "a" or "an" prefix
                        .map(item => item.replace(/^suit of /i, '')) // Remove "suit of" prefix
                        .filter(item => item.length > 0);
                    
                    // Filter only items ending with "potion"
                    const potions = items.filter(item => {
                        const lower = item.toLowerCase();
                        return lower.endsWith('potion') || lower.includes('potion');
                    });
                    
                    waitingForPotions = false;
                    console.log('Potions found:', potions);
                    
                    if (potions.length > 0) {
                        currentPotions = potions;
                        showPopup('Select Potion', potions, (potion) => {
                            sendCommand('drink ' + potion);
                            setTimeout(() => sendCommand('hits'), 100);
                        });
                    } else {
                        // No potions, just send DRINK
                        currentPotions = [];
                        sendCommand('drink');
                    }
                }
            }
        }

        function extractExits() {
            // Look for "Visible exits are:" - use lastIndexOf to find the most recent occurrence
            const searchText = 'Visible exits are:';
            const lastIndex = recentTerminalText.lastIndexOf(searchText);
            
            if (lastIndex !== -1) {
                // Extract text after "Visible exits are:"
                const afterText = recentTerminalText.substring(lastIndex + searchText.length);
                
                // Take until period (including newlines)
                const match = afterText.match(/^([^\n.]+)/);
                
                if (match) {
                    const exitString = match[1];
                    console.log('Exit string found:', exitString);
                    
                    // Split by commas and remove "and"
                    const exits = exitString
                        .toLowerCase()
                        .replace(/\band\b/g, '')
                        .split(/[,\s]+/)
                        .map(e => e.trim())
                        .filter(e => e.length > 0 && e !== '');
                    
                    waitingForExits = false;
                    console.log('Exits parsed:', exits);
                    updateNavButtons(exits);
                }
            }
        }

        function updateNavButtons(availableExits) {
            // Disable all nav buttons first
            const navButtons = ['btnN', 'btnS', 'btnE', 'btnW', 'btnU', 'btnD'];
            const directionMap = {
                'n': 'btnN', 'north': 'btnN',
                's': 'btnS', 'south': 'btnS',
                'e': 'btnE', 'east': 'btnE',
                'w': 'btnW', 'west': 'btnW',
                'u': 'btnU', 'up': 'btnU',
                'd': 'btnD', 'down': 'btnD'
            };
            
            // Disable all buttons
            navButtons.forEach(btnId => {
                const btn = document.getElementById(btnId);
                if (btn) btn.disabled = true;
            });
            
            // Enable only available exits
            availableExits.forEach(exit => {
                const btnId = directionMap[exit];
                if (btnId) {
                    const btn = document.getElementById(btnId);
                    if (btn) btn.disabled = false;
                }
            });
        }

        function enableAllNavButtons() {
            const navButtons = ['btnN', 'btnS', 'btnE', 'btnW', 'btnU', 'btnD'];
            navButtons.forEach(btnId => {
                const btn = document.getElementById(btnId);
                if (btn) btn.disabled = false;
            });
        }

        function updateTargets() {
            const targets = extractTargets(recentTerminalText);
            
            if (targets.length > 0) {
                currentTargets = targets;
                console.log('Targets found:', targets);
            }
        }

        function handleHitButton() {
            // Send LOOK to get fresh target list
            waitingForTargetDetection = true;
            targetDetectionForSpell = false;
            sendCommand('look');
        }

        function handleCastButton() {
            if (currentSpells.length > 0) {
                // Send LOOK to get fresh target list before showing spell selection
                waitingForTargetDetection = true;
                targetDetectionForSpell = true;
                sendCommand('look');
            } else {
                waitingForSpells = true;
                sendCommand('spells');
            }
        }

        function handleDrinkButton() {
            waitingForPotions = true;
            sendCommand('i');
        }

        function handleHelpButton() {
            const topics = [
                'Air', 'Attributes', 'Combat', 'Commands', 'Credits',
                'Earth', 'Elements', 'Experience', 'Fire', 'Gold',
                'Hints', 'Invoking', 'Items', 'Magic', 'Movement',
                'Speed', 'Starting', 'Talismans', 'Water'
            ];
            showPopup('Help Topics', topics, (topic) => {
                sendCommand('help ' + topic);
            });
        }

        function handleSocialButton() {
            const actions = [
                'Bow', 'Blush', 'Burp', 'Chortle', 'Cry', 'Frown',
                'Glare', 'Grin', 'Grumble', 'Hug', 'Kick', 'Kiss',
                'Laugh', 'Nod', 'Smack', 'Smile', 'Smooch', 'Snarl', 'Wave'
            ];
            showPopup('Social Actions', actions, (action) => {
                sendCommand(action);
            });
        }

        function handleShopButton() {
            // Send LOOK command to refresh room info
            waitingForShopDetection = true;
            sendCommand('look');
        }

        function handleEquipButton() {
            const actions = ['Arm', 'Disarm', 'Wear', 'Disrobe'];
            showPopup('Equip', actions, (action) => {
                handleEquipAction(action);
            });
        }

        function handleMapButton() {
            // Detect if mobile or desktop
            const isMobile = window.innerWidth <= 768;
            const mapImage = isMobile ? 'xroads-town-map-small.png' : 'xroads-town-map-medium.png';
            
            showMapPopup(mapImage);
        }

        function handleSettingsButton() {
            showSettingsPopup();
        }

        function showSettingsPopup() {
            const overlay = document.getElementById('popupOverlay');
            const titleEl = document.getElementById('popupTitle');
            const listEl = document.getElementById('popupButtonList');
            
            titleEl.textContent = 'Settings';
            
            listEl.innerHTML = `
                <div class="settings-group">
                    <span class="settings-label">Descriptions</span>
                    <div class="settings-toggle">
                        <button id="descShort" onclick="setDescriptionMode('short')" ${descriptionMode === 'short' ? 'class="active"' : ''}>Short</button>
                        <button id="descLong" onclick="setDescriptionMode('long')" ${descriptionMode === 'long' ? 'class="active"' : ''}>Long</button>
                    </div>
                </div>
                
                <div class="settings-group">
                    <span class="settings-label">Terminal Font Size</span>
                    <div class="font-size-controls">
                        <button class="font-size-btn" onclick="decreaseFontSize()">‚è¨</button>
                        <div class="font-size-display" id="fontSizeDisplay">${terminalFontSize.toFixed(1)}em</div>
                        <button class="font-size-btn" onclick="increaseFontSize()">‚è´</button>
                    </div>
                </div>
            `;
            
            overlay.classList.add('active');
        }

        function setDescriptionMode(mode) {
            descriptionMode = mode;
            localStorage.setItem('bbs_description_mode', mode);
            
            // Update button states
            document.getElementById('descShort').classList.toggle('active', mode === 'short');
            document.getElementById('descLong').classList.toggle('active', mode === 'long');
            
            // Send command
            if (mode === 'short') {
                sendCommand('brief');
            } else {
                sendCommand('verbose');
            }
        }

        function increaseFontSize() {
            if (terminalFontSize < 2.0) {
                terminalFontSize += 0.1;
                applyFontSize();
            }
        }

        function decreaseFontSize() {
            if (terminalFontSize > 0.5) {
                terminalFontSize -= 0.1;
                applyFontSize();
            }
        }

        function applyFontSize() {
            const terminal = document.getElementById('terminal');
            terminal.style.fontSize = terminalFontSize + 'em';
            document.getElementById('fontSizeDisplay').textContent = terminalFontSize.toFixed(1) + 'em';
            localStorage.setItem('bbs_terminal_font_size', terminalFontSize);
        }

        function loadSettings() {
            // Load saved settings
            const savedFontSize = localStorage.getItem('bbs_terminal_font_size');
            if (savedFontSize) {
                terminalFontSize = parseFloat(savedFontSize);
                const terminal = document.getElementById('terminal');
                terminal.style.fontSize = terminalFontSize + 'em';
            }
            
            const savedDescMode = localStorage.getItem('bbs_description_mode');
            if (savedDescMode) {
                descriptionMode = savedDescMode;
            }
        }

        function showMapPopup(imagePath) {
            const overlay = document.getElementById('popupOverlay');
            const titleEl = document.getElementById('popupTitle');
            const listEl = document.getElementById('popupButtonList');
            
            titleEl.textContent = 'Town Map';
            
            // Create image container with zoom capability
            listEl.innerHTML = `
                <div class="map-image-container">
                    <img src="${imagePath}" alt="Town Map" class="map-image" id="mapImage" onclick="toggleMapZoom()">
                </div>
            `;
            
            overlay.classList.add('active');
        }

        function toggleMapZoom() {
            const img = document.getElementById('mapImage');
            if (img) {
                img.classList.toggle('zoomed');
            }
        }

        function handleEquipAction(action) {
            if (action === 'Arm') {
                // Always refresh inventory before showing items
                waitingForArmItems = true;
                sendCommand('i');
            } else if (action === 'Disarm') {
                sendCommand('disarm');
            } else if (action === 'Wear') {
                // Always refresh inventory before showing items
                waitingForWearItems = true;
                sendCommand('i');
            } else if (action === 'Disrobe') {
                sendCommand('disrobe');
            }
        }

        function sendCurrentInput() {
            const input = document.getElementById('commandInput');
            const command = input.value.trim();
            
            if (command) {
                sendCommand(command);
                input.value = '';
            } else {
                // Send just ENTER if input is empty
                sendCommand('');
            }
            input.focus();
        }

        function handleEnter(event) {
            if (event.key === 'Enter') {
                sendCurrentInput();
            }
        }
    </script>
</body>
</html>
