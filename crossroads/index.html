<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>BBS Terminal</title>
    <link href="https://fonts.googleapis.com/css2?family=VT323&family=IBM+Plex+Mono:wght@400;500&display=swap" rel="stylesheet">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <style>
        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --accent-primary: #58a6ff;
            --accent-secondary: #79c0ff;
            --accent-success: #3fb950;
            --accent-warning: #d29922;
            --accent-danger: #f85149;
            --text-primary: #c9d1d9;
            --text-secondary: #8b949e;
            --border-default: #30363d;
            --border-muted: #21262d;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'IBM Plex Mono', monospace;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
        }

        .container {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Login Panel */
        .login-panel {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .login-panel.hidden {
            display: none;
        }

        .login-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-default);
            border-radius: 12px;
            padding: 32px;
            width: 100%;
            max-width: 480px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
        }

        .login-card h2 {
            font-size: 1.5em;
            margin-bottom: 8px;
            color: var(--text-primary);
        }

        .login-card p {
            color: var(--text-secondary);
            margin-bottom: 24px;
            font-size: 0.9em;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            color: var(--text-secondary);
            font-size: 0.85em;
            font-weight: 500;
        }

        .form-group input {
            width: 100%;
            padding: 10px 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-default);
            border-radius: 6px;
            color: var(--text-primary);
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.9em;
            transition: all 0.2s ease;
        }

        .form-group input:focus {
            outline: none;
            border-color: var(--accent-primary);
            background: var(--bg-secondary);
        }

        .connect-btn {
            width: 100%;
            padding: 12px;
            background: var(--accent-primary);
            border: none;
            border-radius: 6px;
            color: #ffffff;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.95em;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .connect-btn:hover {
            background: var(--accent-secondary);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(88, 166, 255, 0.3);
        }

        .connect-btn:active {
            transform: translateY(0);
        }

        /* Main Content */
        .main-content {
            flex: 1;
            display: none;
            flex-direction: column;
            min-height: 0;
        }

        .main-content.active {
            display: flex;
        }

        /* Terminal - Top Half */
        .terminal-container {
            height: 55vh;
            display: flex;
            flex-direction: column;
            padding: 8px 8px 0 8px;
        }

        .terminal {
            flex: 1;
            background: #000000;
            border: 1px solid var(--border-default);
            border-radius: 8px;
            padding: 16px;
            overflow-y: auto;
            font-family: 'VT323', monospace;
            font-size: 1.2em;
            line-height: 1.3;
            color: #a8a8a8;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        @keyframes blink {
            50% { opacity: 0; }
        }

        .terminal::-webkit-scrollbar {
            width: 10px;
        }

        .terminal::-webkit-scrollbar-track {
            background: #000000;
        }

        .terminal::-webkit-scrollbar-thumb {
            background: var(--border-default);
            border-radius: 5px;
        }

        .terminal::-webkit-scrollbar-thumb:hover {
            background: var(--text-secondary);
        }

        /* Bottom Controls Area */
        .controls-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 8px;
            gap: 4px;
            overflow-y: auto;
            min-height: 0;
        }

        .controls-area::-webkit-scrollbar {
            width: 8px;
        }

        .controls-area::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        .controls-area::-webkit-scrollbar-thumb {
            background: var(--border-default);
            border-radius: 4px;
        }

        .controls-area::-webkit-scrollbar-thumb:hover {
            background: var(--text-secondary);
        }

        /* Popup Modal for Button Lists */
        .popup-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .popup-overlay.active {
            display: flex;
        }

        .popup-container {
            background: var(--bg-secondary);
            border: 2px solid var(--accent-primary);
            border-radius: 8px;
            width: 90%;
            max-width: 400px;
            max-height: 70vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        .popup-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            border-bottom: 1px solid var(--border-default);
        }

        .popup-title {
            font-size: 1.1em;
            font-weight: 500;
            color: var(--accent-primary);
        }

        .popup-close {
            width: 32px;
            height: 32px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-default);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 1.2em;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .popup-close:hover {
            background: var(--accent-danger);
            border-color: var(--accent-danger);
            color: #ffffff;
        }

        .popup-content {
            padding: 16px;
            overflow-y: auto;
            flex: 1;
        }

        .popup-content::-webkit-scrollbar {
            width: 8px;
        }

        .popup-content::-webkit-scrollbar-track {
            background: var(--bg-tertiary);
        }

        .popup-content::-webkit-scrollbar-thumb {
            background: var(--border-default);
            border-radius: 4px;
        }

        .popup-content::-webkit-scrollbar-thumb:hover {
            background: var(--text-secondary);
        }

        /* Map Popup - Larger sizing */
        .map-popup-container {
            background: var(--bg-secondary);
            border: 2px solid var(--accent-primary);
            border-radius: 8px;
            width: 90vw;
            max-width: 1200px;
            height: 85vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        .map-popup-content {
            flex: 1;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .popup-button-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .popup-list-btn {
            padding: 12px 16px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-default);
            border-radius: 6px;
            color: var(--text-primary);
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: left;
        }

        .popup-list-btn:hover {
            background: var(--bg-primary);
            border-color: var(--accent-primary);
            transform: translateX(4px);
        }

        .popup-list-btn:active {
            transform: translateX(2px);
        }

        /* Map Image Popup */
        .map-image-container {
            max-width: 90vw;
            max-height: 80vh;
            overflow: auto;
            background: var(--bg-tertiary);
            border-radius: 8px;
            padding: 8px;
        }

        .map-image {
            display: block;
            width: 100%;
            height: auto;
            cursor: zoom-in;
            transition: transform 0.2s ease;
        }

        .map-image.zoomed {
            cursor: zoom-out;
            transform: scale(1.5);
            transform-origin: center;
        }

        @media (max-width: 768px) {
            .map-image.zoomed {
                transform: scale(2);
            }
        }

        /* Settings Controls */
        .settings-group {
            margin: 16px 0;
            padding: 16px;
            background: var(--bg-tertiary);
            border-radius: 6px;
        }

        .settings-label {
            display: block;
            font-size: 0.9em;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }

        .settings-toggle {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
        }

        .settings-toggle button {
            flex: 1;
            padding: 8px 16px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-default);
            border-radius: 4px;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .settings-toggle button.active {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
            color: #ffffff;
        }

        .settings-toggle button:hover:not(.active) {
            background: var(--bg-primary);
            border-color: var(--accent-primary);
        }

        .font-size-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .font-size-btn {
            width: 48px;
            height: 48px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-default);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 1.5em;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .font-size-btn:hover {
            background: var(--bg-primary);
            border-color: var(--accent-primary);
        }

        .font-size-display {
            flex: 1;
            text-align: center;
            font-size: 1em;
            color: var(--text-secondary);
        }

        /* Input Row */
        .input-row {
            display: flex;
            gap: 12px;
        }

        .input-wrapper {
            flex: 1;
            display: flex;
            gap: 8px;
        }

        .input-wrapper input {
            flex: 1;
            padding: 10px 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-default);
            border-radius: 6px;
            color: var(--text-primary);
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.9em;
        }

        .input-wrapper input:focus {
            outline: none;
            border-color: var(--accent-primary);
        }

        .send-btn {
            padding: 10px 20px;
            background: var(--accent-primary);
            border: none;
            border-radius: 6px;
            color: #ffffff;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.9em;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .send-btn:hover {
            background: var(--accent-secondary);
        }

        /* Button Rows */
        .buttons-row {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .all-buttons-container {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .button-row {
            display: flex;
            gap: 4px;
            justify-content: center;
            align-items: center;
        }

        .button-spacer {
            width: 100%;
            max-width: 48px;
            height: 48px;
        }

        /* Prevent iOS double-tap zoom ONLY on control buttons */
        .no-zoom {
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        .control-btn {
            padding: 4px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-default);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 1.6em;
            cursor: pointer;
            transition: all 0.15s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 48px;
            height: 48px;
        }

        .control-btn:hover:not(:disabled) {
            background: var(--bg-primary);
            border-color: var(--accent-primary);
            transform: scale(1.05);
        }

        .control-btn:active:not(:disabled) {
            transform: scale(0.95);
        }

        .control-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        /* Target buttons - hidden by default */
        .target-buttons {
            display: none;
            flex-direction: column;
            gap: 2px;
            margin-top: 2px;
            position: absolute;
            z-index: 100;
            min-width: 120px;
        }

        .target-buttons.active {
            display: flex;
        }

        .target-btn {
            padding: 4px 8px;
            background: var(--bg-tertiary);
            border: 1px solid var(--accent-warning);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 0.75em;
            cursor: pointer;
            transition: all 0.15s ease;
            text-align: left;
            white-space: nowrap;
        }

        .target-btn:hover {
            background: var(--bg-primary);
            border-color: var(--accent-primary);
        }

        /* Spell buttons */
        .spell-buttons {
            display: none;
            flex-direction: column;
            gap: 2px;
            margin-top: 2px;
            position: absolute;
            z-index: 100;
            min-width: 120px;
        }

        .spell-buttons.active {
            display: flex;
        }

        .spell-btn {
            padding: 4px 8px;
            background: var(--bg-tertiary);
            border: 1px solid var(--accent-primary);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 0.75em;
            cursor: pointer;
            transition: all 0.15s ease;
            text-align: left;
            white-space: nowrap;
        }

        .spell-btn:hover {
            background: var(--bg-primary);
            border-color: var(--accent-secondary);
        }

        /* Dynamic Buttons */
        .dynamic-section {
            display: none;
        }

        .dynamic-section.active {
            display: block;
        }

        .dynamic-btn {
            background: linear-gradient(135deg, rgba(255, 165, 0, 0.15), rgba(255, 215, 0, 0.15));
            border-color: var(--accent-warning);
        }

        .dynamic-btn:hover {
            background: linear-gradient(135deg, rgba(255, 165, 0, 0.25), rgba(255, 215, 0, 0.25));
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .terminal-container {
                height: 50vh;
            }

            .terminal {
                font-size: 0.7em;
            }

            .buttons-row {
                flex-direction: column;
                gap: 4px;
            }
        }

        @media (max-width: 600px) {
            .header {
                padding: 10px 12px;
            }

            .header-title h1 {
                font-size: 1.4em;
            }

            .login-card {
                padding: 24px;
            }

            .key-btn {
                min-width: 32px;
                height: 36px;
                font-size: 0.8em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Login Panel -->
        <div class="login-panel" id="loginPanel">
            <div class="login-card">
                <h2>Connect to BBS</h2>
                <p>Enter connection details and credentials</p>
                <div class="form-group">
                    <label for="wsUrl">WebSocket URL</label>
                    <input type="text" id="wsUrl" placeholder="wss://server.com/host/port" value="wss://unabruptly-multiplated-kory.ngrok-free.dev:443/192.168.40.69/23">
                </div>
                <div class="form-group">
                    <label for="username">Username</label>
                    <input type="text" id="username" placeholder="Your username">
                </div>
                <div class="form-group">
                    <label for="password">Password</label>
                    <input type="password" id="password" placeholder="Your password">
                </div>
                <div class="form-group" style="display: flex; align-items: center; gap: 8px;">
                    <input type="checkbox" id="newUser" style="width: auto; margin: 0;">
                    <label for="newUser" style="margin: 0; cursor: pointer;">New User (skip auto-login)</label>
                </div>
                <button class="connect-btn" onclick="connect()">Connect</button>
            </div>
        </div>

        <!-- Main Content -->
        <div class="main-content" id="mainContent">
            <!-- Terminal - Top Half -->
            <div class="terminal-container">
                <div class="terminal" id="terminal"></div>
            </div>

            <!-- Bottom Controls Area -->
            <div class="controls-area">
                <!-- Input Row -->
                <div class="input-row">
                    <div class="input-wrapper">
                        <input type="text" id="commandInput" placeholder="Type command..." onkeypress="handleEnter(event)">
                        <button class="send-btn" onclick="sendCurrentInput()">Send</button>
                    </div>
                </div>

                <!-- Buttons Row -->
                <div class="buttons-row">
                    <div class="all-buttons-container">
                        <!-- Row 1: HIT, CAST, DRINK, <empty>, LOOK, N, U -->
                        <div class="button-row">
                            <button class="control-btn no-zoom" onclick="handleHitButton()" title="Hit">‚öîÔ∏è</button>
                            <button class="control-btn no-zoom" onclick="handleCastButton()" title="Cast">üìñ</button>
                            <button class="control-btn no-zoom" onclick="handleDrinkButton()" title="Drink">üíß</button>
                            <div class="button-spacer"></div>
                            <button class="control-btn no-zoom" onclick="sendCommand('look')" title="Look">üëÅÔ∏è</button>
                            <button class="control-btn no-zoom" id="btnN" onclick="sendDirectional('n')" title="North">‚¨ÜÔ∏è</button>
                            <button class="control-btn no-zoom" id="btnU" onclick="sendDirectional('u')" title="Up">‚§¥Ô∏è</button>
                        </div>
                        
                        <!-- Row 2: I, EQUIP, HITS, <empty>, W, EX, E -->
                        <div class="button-row">
                            <button class="control-btn no-zoom" onclick="sendCommand('i')" title="Inventory">üëú</button>
                            <button class="control-btn no-zoom" onclick="handleEquipButton()" title="Equip">üõ°Ô∏è</button>
                            <button class="control-btn no-zoom" onclick="sendCommand('hits')" title="HP/SP">‚ù§Ô∏è‚Äçü©π</button>
                            <div class="button-spacer"></div>
                            <button class="control-btn no-zoom" id="btnW" onclick="sendDirectional('w')" title="West">‚¨ÖÔ∏è</button>
                            <button class="control-btn no-zoom" onclick="handleExitsButton()" title="Exits">üö™</button>
                            <button class="control-btn no-zoom" id="btnE" onclick="sendDirectional('e')" title="East">‚û°Ô∏è</button>
                        </div>
                        
                        <!-- Row 3: SHOP, SOCIAL, STATS, <empty>, MAP, S, D -->
                        <div class="button-row">
                            <button class="control-btn no-zoom" onclick="handleShopButton()" title="Shop">üí≤</button>
                            <button class="control-btn no-zoom" onclick="handleSocialButton()" title="Social">üòÄ</button>
                            <button class="control-btn no-zoom" onclick="sendCommand('stats')" title="Stats">üìä</button>
                            <div class="button-spacer"></div>
                            <button class="control-btn no-zoom" onclick="handleMapButton()" title="Map">üåé</button>
                            <button class="control-btn no-zoom" id="btnS" onclick="sendDirectional('s')" title="South">‚¨áÔ∏è</button>
                            <button class="control-btn no-zoom" id="btnD" onclick="sendDirectional('d')" title="Down">‚§µÔ∏è</button>
                        </div>

                        <!-- Row 4: HELP, SETTINGS, <empty>, <empty>, <empty>, <empty>, <empty> -->
                        <div class="button-row">
                            <button class="control-btn no-zoom" onclick="handleHelpButton()" title="Help">‚ùì</button>
                            <button class="control-btn no-zoom" onclick="handleSettingsButton()" title="Settings">‚öôÔ∏è</button>
                            <div class="button-spacer"></div>
                            <div class="button-spacer"></div>
                            <div class="button-spacer"></div>
                            <div class="button-spacer"></div>
                            <div class="button-spacer"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Popup Modal for Button Lists -->
    <div class="popup-overlay" id="popupOverlay" onclick="closePopupIfClickedOutside(event)">
        <div class="popup-container" onclick="event.stopPropagation()">
            <div class="popup-header">
                <div class="popup-title" id="popupTitle">Select</div>
                <button class="popup-close" onclick="closePopup()">‚úï</button>
            </div>
            <div class="popup-content">
                <div class="popup-button-list" id="popupButtonList"></div>
            </div>
        </div>
    </div>

    <!-- Map Popup Modal (Larger, Separate) -->
    <div class="popup-overlay" id="mapPopupOverlay" onclick="closeMapPopup(event)">
        <div class="map-popup-container" onclick="event.stopPropagation()">
            <div class="popup-header">
                <div class="popup-title" id="mapPopupTitle">Map</div>
                <button class="popup-close" onclick="closeMapPopup()">‚úï</button>
            </div>
            <div class="map-popup-content" id="mapPopupContent"></div>
        </div>
    </div>

    <script>
        // Global variables
        let ws = null;
        let isConnected = false;
        let currentTerminalText = '';
        let recentTerminalText = '';
        let currentTargets = []; // Store current targets from "There is a ... here."
        let currentANSIStyle = ''; // Persist ANSI color state across chunks
        let ansiFg = '';       // Current foreground color hex
        let ansiBold = false;  // Current bold state
        let ansiBlink = false; // Current blink state
        let waitingForMapLook = false;  // Waiting for LOOK to match room
        let mapData = null;    // Cached map JSON data
        let currentSpells = []; // Store user's spells
        let selectedSpell = null; // Currently selected spell for casting
        let waitingForSpells = false; // Waiting for spell list from server
        let waitingForExits = false; // Waiting for exit list from server
        let currentPotions = []; // Store available potions
        let waitingForPotions = false; // Waiting for inventory to extract potions
        let waitingForSpellRefresh = false; // Waiting to check if CAST failed and needs spell list
        let waitingForShopItems = false; // Waiting for shop inventory
        let waitingForSellItems = false; // Waiting for sell inventory
        let waitingForAppraiseItems = false; // Waiting for appraise inventory
        let currentShopkeeper = null; // Current shopkeeper name
        let currentUsername = ''; // Logged-in username
        let waitingForArmItems = false; // Waiting for arm inventory
        let waitingForWearItems = false; // Waiting for wear inventory
        let terminalFontSize = 1.2; // Current terminal font size in em
        let descriptionMode = 'long'; // 'short' or 'long'
        let waitingForShopDetection = false; // Waiting to detect shopkeeper before showing shop menu
        let waitingForGoldCheck = false; // Waiting to check player gold before buying
        let playerGold = 0; // Current player gold
        let currentShopItems = []; // Items in shop with prices
        let waitingForTargetDetection = false; // Waiting for LOOK to detect targets
        let targetDetectionForSpell = false; // Track if target detection is for spell casting

        // Popup control functions
        function showPopup(title, buttons, onClickCallback) {
            const overlay = document.getElementById('popupOverlay');
            const titleEl = document.getElementById('popupTitle');
            const listEl = document.getElementById('popupButtonList');
            
            titleEl.textContent = title;
            listEl.innerHTML = '';
            
            buttons.forEach(button => {
                const btn = document.createElement('button');
                btn.className = 'popup-list-btn';
                btn.textContent = button.label || button;
                btn.onclick = () => {
                    const value = button.value || button;
                    closePopup();
                    // Call callback AFTER popup is closed to prevent race conditions
                    setTimeout(() => {
                        onClickCallback(value);
                    }, 50);
                };
                listEl.appendChild(btn);
            });
            
            overlay.classList.add('active');
        }

        function closePopup() {
            const overlay = document.getElementById('popupOverlay');
            overlay.classList.remove('active');
        }

        function closePopupIfClickedOutside(event) {
            if (event.target.id === 'popupOverlay') {
                closePopup();
            }
        }

        // Telnet IAC (Interpret As Command) constants
        const IAC = 255;  // 0xFF
        const DONT = 254; // 0xFE
        const DO = 253;   // 0xFD
        const WONT = 252; // 0xFC
        const WILL = 251; // 0xFB
        const SB = 250;   // 0xFA - Subnegotiation Begin
        const SE = 240;   // 0xF0 - Subnegotiation End

        // ANSI color map
        const ANSI_COLORS = {
            // Standard colors (30-37)
            '30': '#000000',  // Black        (Colour 0)
            '31': '#a80000',  // Red          (Colour 4)
            '32': '#00a800',  // Green        (Colour 2)
            '33': '#a85400',  // Brown/Yellow (Colour 6)
            '34': '#0000a8',  // Blue         (Colour 1)
            '35': '#a800a8',  // Magenta      (Colour 5)
            '36': '#00a8a8',  // Cyan         (Colour 3)
            '37': '#a8a8a8',  // Gray         (Colour 7)
            // Bright colors (90-97) ‚Äî also triggered by bold+standard
            '90': '#545454',  // Dark Gray    (Colour 8)
            '91': '#ff5454',  // Bright Red   (Colour 12)
            '92': '#54ff54',  // Bright Green (Colour 10)
            '93': '#ffff54',  // Bright Yellow(Colour 14)
            '94': '#5454ff',  // Bright Blue  (Colour 9)
            '95': '#ff54ff',  // Bright Magenta(Colour 13)
            '96': '#54ffff',  // Bright Cyan  (Colour 11)
            '97': '#ffffff',  // Bright White (Colour 15)
        };

        // CP437 ‚Üí Unicode lookup table (indices 0-255)
        // Only printable range 32-255 needed; control chars handled separately
        const CP437 = [
            /* 0x00 */ '\u0000','\u263A','\u263B','\u2665','\u2666','\u2663','\u2660','\u2022',
            /* 0x08 */ '\u25D8','\u25CB','\u25D9','\u2642','\u2640','\u266A','\u266B','\u263C',
            /* 0x10 */ '\u25BA','\u25C4','\u2195','\u203C','\u00B6','\u00A7','\u25AC','\u21A8',
            /* 0x18 */ '\u2191','\u2193','\u2192','\u2190','\u221F','\u2194','\u25B2','\u25BC',
            /* 0x20 */ ' ','!','"','#','$','%','&',"'",'(',')','*','+',',','-','.','/',
            /* 0x30 */ '0','1','2','3','4','5','6','7','8','9',':',';','<','=','>','?',
            /* 0x40 */ '@','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O',
            /* 0x50 */ 'P','Q','R','S','T','U','V','W','X','Y','Z','[','\\',']','^','_',
            /* 0x60 */ '`','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o',
            /* 0x70 */ 'p','q','r','s','t','u','v','w','x','y','z','{','|','}','~','\u2302',
            /* 0x80 */ '\u00C7','\u00FC','\u00E9','\u00E2','\u00E4','\u00E0','\u00E5','\u00E7',
            /* 0x88 */ '\u00EA','\u00EB','\u00E8','\u00EF','\u00EE','\u00EC','\u00C4','\u00C5',
            /* 0x90 */ '\u00C9','\u00E6','\u00C6','\u00F4','\u00F6','\u00F2','\u00FB','\u00F9',
            /* 0x98 */ '\u00FF','\u00D6','\u00DC','\u00A2','\u00A3','\u00A5','\u20A7','\u0192',
            /* 0xA0 */ '\u00E1','\u00ED','\u00F3','\u00FA','\u00F1','\u00D1','\u00AA','\u00BA',
            /* 0xA8 */ '\u00BF','\u2310','\u00AC','\u00BD','\u00BC','\u00A1','\u00AB','\u00BB',
            /* 0xB0 */ '\u2591','\u2592','\u2593','\u2502','\u2524','\u2561','\u2562','\u2556',
            /* 0xB8 */ '\u2555','\u2563','\u2551','\u2557','\u255D','\u255C','\u255B','\u2510',
            /* 0xC0 */ '\u2514','\u2534','\u252C','\u251C','\u2500','\u253C','\u255E','\u255F',
            /* 0xC8 */ '\u255A','\u2554','\u2569','\u2566','\u2560','\u2550','\u256C','\u2567',
            /* 0xD0 */ '\u2568','\u2564','\u2565','\u2559','\u2558','\u2552','\u2553','\u256B',
            /* 0xD8 */ '\u256A','\u2518','\u250C','\u2588','\u2584','\u258C','\u2590','\u2580',
            /* 0xE0 */ '\u03B1','\u00DF','\u0393','\u03C0','\u03A3','\u03C3','\u00B5','\u03C4',
            /* 0xE8 */ '\u03A6','\u0398','\u03A9','\u03B4','\u221E','\u03C6','\u03B5','\u2229',
            /* 0xF0 */ '\u2261','\u00B1','\u2265','\u2264','\u2320','\u2321','\u00F7','\u2248',
            /* 0xF8 */ '\u00B0','\u2219','\u00B7','\u221A','\u207F','\u00B2','\u25A0','\u00A0',
        ];

        // Bold (code 1) shifts standard foreground colors to bright equivalents
        const BOLD_COLOR_MAP = {
            '30': '90', '31': '91', '32': '92', '33': '93',
            '34': '94', '35': '95', '36': '96', '37': '97'
        };



        // Dynamic button rules
        // Load saved credentials
        window.addEventListener('DOMContentLoaded', () => {
            const saved = {
                wsUrl: localStorage.getItem('bbs_ws_url'),
                username: localStorage.getItem('bbs_username'),
                password: localStorage.getItem('bbs_password')
            };
            
            if (saved.wsUrl) document.getElementById('wsUrl').value = saved.wsUrl;
            if (saved.username) document.getElementById('username').value = saved.username;
            if (saved.password) document.getElementById('password').value = saved.password;
            
            // Load settings
            loadSettings();
        });

        function connect() {
            const wsUrl = document.getElementById('wsUrl').value.trim();
            const username = document.getElementById('username').value.trim();
            const password = document.getElementById('password').value.trim();
            const isNewUser = document.getElementById('newUser').checked;

            if (!wsUrl) {
                alert('Please enter a WebSocket URL');
                return;
            }

            // Save credentials and username
            localStorage.setItem('bbs_ws_url', wsUrl);
            localStorage.setItem('bbs_username', username);
            localStorage.setItem('bbs_password', password);
            currentUsername = username; // Store for self-targeting spells

            // Hide login, show terminal
            document.getElementById('loginPanel').classList.add('hidden');
            document.getElementById('mainContent').classList.add('active');

            // Clear terminal
            document.getElementById('terminal').innerHTML = '';
            currentTerminalText = '';
            recentTerminalText = '';

            appendToTerminal('Connecting to ' + wsUrl + '...\n');

            try {
                ws = new WebSocket(wsUrl);
                ws.binaryType = 'arraybuffer';  // Important for binary telnet data!

                ws.onopen = function() {
                    isConnected = true;
                    appendToTerminal('‚úì Connected!\n\n');
                    
                    // Auto-login sequence (skip if new user checkbox is checked)
                    if (!isNewUser && username && password) {
                        setTimeout(() => sendCommand(username), 3000);
                        setTimeout(() => sendCommand(password), 3100);
                        setTimeout(() => sendCommand('q'), 3600);  // 500ms after password
                        setTimeout(() => sendCommand('g'), 3800);  // 200ms after Q
                        setTimeout(() => sendCommand('q'), 4000);  // 200ms after G
                        setTimeout(() => sendCommand('5'), 4200);  // 200ms after Q
                        setTimeout(() => sendCommand('p'), 4400);  // 200ms after 5
                    }
                };

                ws.onmessage = function(event) {
                    let data;
                    
                    // Handle binary data - decode as CP437, NOT UTF-8
                    if (event.data instanceof ArrayBuffer) {
                        const bytes = new Uint8Array(event.data);
                        const filtered = filterTelnetIAC(bytes);
                        // Decode using CP437 map
                        let decoded = '';
                        for (let i = 0; i < filtered.length; i++) {
                            const b = filtered[i];
                            // Preserve control codes needed for ANSI sequences and terminal
                            if (b === 0x1B || b === 0x0D || b === 0x0A || b === 0x08 || b === 0x09 || b === 0x07) {
                                decoded += String.fromCharCode(b);
                            } else if (b < 32) {
                                // Skip other control chars (NUL, XON, XOFF, etc.)
                                continue;
                            } else {
                                decoded += CP437[b] || String.fromCharCode(b);
                            }
                        }
                        data = decoded;
                    } else {
                        data = event.data;
                    }

                    if (data.length > 0) {
                        appendToTerminal(data);
                        
                        // Store text for dynamic buttons and target extraction
                        const plainText = stripANSI(data);
                        currentTerminalText += plainText;
                        recentTerminalText += plainText;
                        
                        // Keep buffers manageable
                        if (currentTerminalText.length > 10000) {
                            currentTerminalText = currentTerminalText.slice(-10000);
                        }
                        if (recentTerminalText.length > 1024) {
                            recentTerminalText = recentTerminalText.slice(-1024);
                        }
                        
                        // Extract targets from recent text
                        updateTargets();
                        
                        // Extract spells if waiting for them
                        if (waitingForSpells) {
                            extractSpells();
                        }
                        
                        // Extract exits if waiting for them
                        if (waitingForExits) {
                            extractExits();
                        }
                        
                        // Extract potions if waiting for them
                        if (waitingForPotions) {
                            extractPotions();
                        }
                        
                        // Check for spell refresh needed
                        if (waitingForSpellRefresh) {
                            checkForSpellRefresh();
                        }
                        
                        // Check for item drops
                        checkForItemDrops(plainText);
                        
                        // Extract shop items if waiting
                        if (waitingForShopItems) {
                            extractShopItems();
                        }
                        
                        // Extract sell/appraise items if waiting
                        if (waitingForSellItems || waitingForAppraiseItems) {
                            extractInventoryForShop();
                        }
                        
                        // Extract arm/wear items if waiting
                        if (waitingForArmItems || waitingForWearItems) {
                            extractInventoryForEquip();
                        }
                        
                        // Check for shopkeeper detection
                        if (waitingForShopDetection) {
                            checkForShopkeeper();
                        }
                        
                        // Check for gold amount
                        if (waitingForGoldCheck) {
                            extractPlayerGold();
                        }
                        
                        // Check for target detection
                        if (waitingForTargetDetection) {
                            detectTargetsFromLook();
                        }
                        
                        // Check for map room matching
                        if (waitingForMapLook) {
                            detectAndShowMap();
                        }
                    }
                };

                ws.onerror = function(error) {
                    console.error('WebSocket error:', error);
                    isConnected = false;
                    appendToTerminal('\n‚úó Connection error\n');
                };

                ws.onclose = function(event) {
                    console.log('WebSocket closed:', event.code, event.reason);
                    isConnected = false;
                    appendToTerminal('\n[Connection closed]\n');
                };
            } catch (e) {
                appendToTerminal('\n‚úó Error: ' + e.message + '\n');
            }
        }

        function filterTelnetIAC(bytes) {
            const filtered = [];
            let i = 0;

            while (i < bytes.length) {
                if (bytes[i] === IAC) {
                    // Check for IAC IAC (escaped 255)
                    if (i + 1 < bytes.length && bytes[i + 1] === IAC) {
                        filtered.push(IAC);
                        i += 2;
                        continue;
                    }

                    // Handle IAC commands
                    if (i + 2 < bytes.length) {
                        const cmd = bytes[i + 1];
                        
                        // Check for subnegotiation
                        if (cmd === SB) {
                            // Skip until SE
                            i += 2;
                            while (i < bytes.length && !(bytes[i] === IAC && i + 1 < bytes.length && bytes[i + 1] === SE)) {
                                i++;
                            }
                            i += 2; // Skip IAC SE
                            continue;
                        }
                        
                        // Skip DO, DONT, WILL, WONT commands (3 bytes)
                        if (cmd === DO || cmd === DONT || cmd === WILL || cmd === WONT) {
                            i += 3;
                            continue;
                        }
                    }
                    
                    i++;
                } else {
                    filtered.push(bytes[i]);
                    i++;
                }
            }

            return new Uint8Array(filtered);
        }

        function appendToTerminal(text) {
            const terminal = document.getElementById('terminal');
            const processed = processANSI(text);
            terminal.innerHTML += processed;
            terminal.scrollTop = terminal.scrollHeight;
        }

        function stripANSI(text) {
            return text.replace(/\x1b\[[0-9;]*m/g, '').replace(/\x1b\[.*?[@-~]/g, '');
        }

        function buildAnsiStyle() {
            // Build CSS style string from current ANSI state
            let color = ansiFg;
            // Bold shifts standard colors to bright equivalents
            if (ansiBold && BOLD_COLOR_MAP[ansiFg]) {
                color = BOLD_COLOR_MAP[ansiFg];
            }
            const hex = ANSI_COLORS[color] || '';
            let style = hex ? `color: ${hex}` : '';
            if (ansiBold && !hex) style += (style ? '; ' : '') + 'font-weight: bold';
            if (ansiBlink) style += (style ? '; ' : '') + 'animation: blink 1s step-start infinite';
            return style;
        }

        function processANSI(text) {
            // XP table for level progression
            const xpTable = [
                0, 121, 301, 587, 1082, 1866, 3180, 5251, 8674, 14042,
                22826, 36551, 58772, 93324, 148854, 234910, 372322, 584686,
                921970, 1441931, 2264012, 3528732, 5520666, 8579686, 13381636,
                20744626, 32269282, 49916387, 77467454, 119604354
            ];

            // Process Experience line to show next level XP
            text = text.replace(/Experience\s+:\s+(\d+)/g, (match, currentXP) => {
                const xp = parseInt(currentXP.replace(/,/g, ''));
                let nextLevelXP = null;
                for (let i = 0; i < xpTable.length; i++) {
                    if (xpTable[i] > xp) { nextLevelXP = xpTable[i]; break; }
                }
                return nextLevelXP !== null
                    ? `Experience  : ${currentXP} / ${nextLevelXP.toLocaleString()}`
                    : match;
            });

            // Strip all non-color ANSI sequences FIRST
            // ESC [ <digits/semicolons> <non-m letter>  ‚Äî cursor, erase, etc.
            text = text.replace(/\x1b\[[\d;]*[ABCDEFGHJKLMPSTXZfhinsu]/g, '');
            // ESC [ ! <anything>  ‚Äî telnet/terminal reset sequences like ESC[!
            text = text.replace(/\x1b\[![\x00-\xff]*/g, '');
            // ESC <single non-[ char>  ‚Äî ESC c, ESC 7, ESC 8, etc.
            text = text.replace(/\x1b[^\[]/g, '');

            // Apply our custom line-color rules BEFORE HTML escaping
            const lines = text.split(/\r\n|\r|\n/);
            const coloredLines = [];
            for (let i = 0; i < lines.length; i++) {
                let line = lines[i];
                const trimmedLine = line.trim();
                if (!trimmedLine) { coloredLines.push(line); continue; }

                // Check line endings and wrap with color markers
                let colorCode = null;
                //if (trimmedLine.endsWith('points!')) {
                //    colorCode = '#d29922';
                //} else if (trimmedLine.endsWith('black smoke!')) {
                //    colorCode = '#54ff54';
                //} else if (trimmedLine.endsWith('but misses!')) {
                //    colorCode = '#a8a8a8';
                //} else if (trimmedLine.endsWith('you!')) {
                //    colorCode = '#ff5454';
                //} else if (trimmedLine.endsWith('falls to the ground!')) {
                //    colorCode = '#bc8cff';
                //} else if (trimmedLine.includes('The spell fizzled!')) {
                //    colorCode = '#ff5454';
                if (trimmedLine.endsWith(' is here.')) {
                    colorCode = '#bc8cff';
                } else if (trimmedLine.startsWith('There is a ') && trimmedLine.endsWith(' here.')) {
                    colorCode = '#d29922';
                }

                if (colorCode) {
                    line = `\x1b[COLOR:${colorCode}]${line}\x1b[COLOREND]`;
                }
                coloredLines.push(line);
            }
            text = coloredLines.join('\n');

            // Escape HTML
            text = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

            // Match ANSI color codes (ESC[...m) and our custom COLOR markers
            const regex = /\x1b\[([0-9;]*)m|\x1b\[COLOR:(#[0-9a-fA-F]{6})\]|\x1b\[COLOREND\]/g;
            let result = '';
            let lastIndex = 0;
            let customColor = null;

            text.replace(regex, (match, codes, color, offset) => {
                // Emit text before this escape code
                if (offset > lastIndex) {
                    const textBefore = text.substring(lastIndex, offset);
                    const style = customColor
                        ? `color: ${customColor}`
                        : buildAnsiStyle();
                    result += style
                        ? `<span style="${style}">${textBefore}</span>`
                        : textBefore;
                }

                if (color) {
                    // Our custom line color override
                    customColor = color;
                } else if (match === '\x1b[COLOREND]') {
                    customColor = null;
                } else if (codes !== undefined) {
                    // Parse semicolon-separated ANSI codes
                    const codeList = codes.split(';').map(c => c.trim()).filter(c => c !== '');
                    if (codeList.length === 0 || codeList[0] === '0') {
                        // Full reset
                        ansiFg = '';
                        ansiBold = false;
                        ansiBlink = false;
                    } else {
                        for (const code of codeList) {
                            if (code === '1') {
                                ansiBold = true;
                            } else if (code === '5') {
                                ansiBlink = true;
                            } else if (ANSI_COLORS[code] !== undefined) {
                                ansiFg = code; // Store the code, not the hex
                            }
                        }
                    }
                }

                lastIndex = offset + match.length;
                return '';
            });

            // Emit any remaining text
            if (lastIndex < text.length) {
                const textAfter = text.substring(lastIndex);
                const style = customColor
                    ? `color: ${customColor}`
                    : buildAnsiStyle();
                result += style
                    ? `<span style="${style}">${textAfter}</span>`
                    : textAfter;
            }

            return result;
        }

        function sendCommand(command) {
            if (!isConnected || !ws || ws.readyState !== WebSocket.OPEN) {
                alert('Not connected');
                return;
            }

            try {
                // Send as binary (Uint8Array) instead of text
                const encoder = new TextEncoder();
                const data = encoder.encode(command + '\r\n');
                ws.send(data.buffer);
            } catch (e) {
                console.error('Send error:', e);
            }
        }

        function sendDirectional(direction) {
            // Clear targets when moving
            currentTargets = [];
            
            // Re-enable all nav buttons when moving
            enableAllNavButtons();
            
            // Send the directional command
            sendCommand(direction);
            
            // Auto-trigger exits check after a short delay
            setTimeout(() => {
                handleExitsButton();
            }, 500);
        }

        function handleExitsButton() {
            // Request exits from server
            waitingForExits = true;
            sendCommand('ex');
        }

        function extractTargets(text) {
            // First find the last occurrence of "...You" to get the most recent room description
            const youIndex = text.lastIndexOf('...You');
            
            // If "...You" is found, only look for targets after that point
            const searchText = youIndex !== -1 ? text.substring(youIndex) : text;
            
            // Look for pattern: "There is a ... here."
            const regex = /There is (?:a |an )?(.*?) here\./gi;
            const matches = [...searchText.matchAll(regex)];
            
            if (matches.length > 0) {
                // Get the last match (most recent)
                const lastMatch = matches[matches.length - 1];
                const targetString = lastMatch[1];
                
                // Split by "and" and commas to get individual targets
                const targets = targetString
                    .split(/(?:\s+and\s+|,\s*)/)
                    .map(t => t.trim())
                    .map(t => t.replace(/^(a |an )/i, '')) // Remove "a" or "an" prefix
                        .map(item => item.replace(/^suit of /i, '')) // Remove "suit of" prefix
                    .filter(t => t.length > 0);
                
                return targets;
            }
            
            return [];
        }

        function extractSpells() {
            // Look for "You have the ability to cast:" followed by spell names across multiple lines
            // The spell list ends when we hit a prompt ")" or another command
            const startMatch = recentTerminalText.match(/You have the ability to cast:\s*/i);
            
            if (startMatch) {
                const startPos = startMatch.index + startMatch[0].length;
                const afterCast = recentTerminalText.substring(startPos);
                
                // Extract everything until we hit a prompt ")" or end of text
                const endMatch = afterCast.match(/\n\s*\)/);
                const spellBlock = endMatch 
                    ? afterCast.substring(0, endMatch.index)
                    : afterCast;
                
                // Split by whitespace (spaces, tabs, newlines) to get individual spell names
                const spells = spellBlock
                    .split(/\s+/)
                    .map(s => s.trim())
                    .filter(s => s.length > 0 && s !== ')');
                
                if (spells.length > 0) {
                    currentSpells = spells;
                    waitingForSpells = false;
                    console.log('Spells found:', spells);
                    // Auto-show spell list in popup
                    showPopup('Select Spell', currentSpells, (spell) => {
                        selectedSpell = spell;
                        if (currentTargets.length > 0) {
                            showPopup('Select Target', currentTargets, (target) => {
                                sendCommand('cast ' + selectedSpell + ' ' + target);
                                selectedSpell = null;
                                waitingForSpellRefresh = true;
                                setTimeout(() => sendCommand('hits'), 100);
                            });
                        } else {
                            sendCommand('cast ' + selectedSpell);
                            selectedSpell = null;
                        }
                    });
                }
            }
        }

        function handleShopAction(action) {
            if (action === 'Buy') {
                // Check player gold first, then look at shopkeeper
                waitingForGoldCheck = true;
                sendCommand('i');
            } else if (action === 'Sell') {
                waitingForSellItems = true;
                sendCommand('i');
            } else if (action === 'Appraise') {
                waitingForAppraiseItems = true;
                sendCommand('i');
            }
        }

        function findShopkeeper() {
            // Known shopkeeper names
            const shopkeeperNames = [
                'monk', 'Oria', 'Zell', 'Hanrod', 'Wenzel', 'Izalig',
                'Amaranth', 'Klemm', 'Hebezega', 'Black', 'Lor', 'Dara',
                'Marna', 'Arond', 'Jomb', 'Mokkis', 'Roltima'
            ];
            
            // Find last occurrence of "here."
            const lastIndex = recentTerminalText.lastIndexOf('here.');
            
            if (lastIndex !== -1) {
                // Get text before "here." to find the sentence
                const beforeText = recentTerminalText.substring(0, lastIndex);
                
                // Find the start of this sentence (look for previous period or start of text)
                const lastPeriod = beforeText.lastIndexOf('.');
                const sentenceStart = lastPeriod !== -1 ? lastPeriod + 1 : 0;
                const sentence = recentTerminalText.substring(sentenceStart, lastIndex + 5); // Include "here."
                
                console.log('Shopkeeper search - sentence:', sentence);
                
                // Check if any shopkeeper name is in this sentence
                for (const name of shopkeeperNames) {
                    if (sentence.includes(name)) {
                        console.log('Found shopkeeper:', name);
                        return name;
                    }
                }
            }
            
            console.log('No shopkeeper found');
            return null;
        }

        function detectTargetsFromLook() {
            waitingForTargetDetection = false;
            
            // Extract targets from the recent LOOK output
            currentTargets = extractTargets(recentTerminalText);
            
            if (targetDetectionForSpell) {
                // Show spell selection, which will then show targets
                showPopup('Select Spell', currentSpells, (spell) => {
                    selectedSpell = spell;
                    console.log('Spell selected:', selectedSpell);
                    
                    // Show targets including "(no target)" for self-casting
                    const targets = [...currentTargets];
                    targets.push('(no target)'); // Always add no-target option
                    
                    console.log('Showing targets:', targets);
                    showTargetPopup(targets, (target) => {
                        console.log('Target selected:', target);
                        if (target === '(no target)') {
                            // Cast without target (game defaults to self)
                            sendCommand('cast ' + selectedSpell);
                        } else {
                            sendCommand('cast ' + selectedSpell + ' ' + target);
                        }
                        selectedSpell = null;
                        waitingForSpellRefresh = true;
                        setTimeout(() => sendCommand('hits'), 100);
                    });
                });
            } else {
                // Show targets for HIT
                if (currentTargets.length > 0) {
                    showTargetPopup(currentTargets, (target) => {
                        sendCommand('hit ' + target);
                        setTimeout(() => sendCommand('hits'), 100);
                    });
                } else {
                    sendCommand('hit');
                }
            }
        }

        function showTargetPopup(targets, onClickCallback) {
            const overlay = document.getElementById('popupOverlay');
            const titleEl = document.getElementById('popupTitle');
            const listEl = document.getElementById('popupButtonList');
            
            titleEl.textContent = 'Select Target';
            listEl.innerHTML = '';
            
            targets.forEach(target => {
                const btn = document.createElement('button');
                btn.className = 'popup-list-btn';
                btn.textContent = target;
                
                // Color targets in red except for "(no target)"
                if (target !== '(no target)') {
                    btn.style.color = '#ff4444';
                }
                
                btn.onclick = () => {
                    closePopup();
                    setTimeout(() => {
                        onClickCallback(target);
                    }, 50);
                };
                listEl.appendChild(btn);
            });
            
            overlay.classList.add('active');
        }

        function checkForShopkeeper() {
            waitingForShopDetection = false;
            const shopkeeper = findShopkeeper();
            
            if (shopkeeper) {
                currentShopkeeper = shopkeeper;
                // Show shop menu
                const actions = ['Buy', 'Sell', 'Appraise'];
                showPopup('Shop', actions, (action) => {
                    handleShopAction(action);
                });
            } else {
                alert('No shopkeeper found in this room');
            }
        }

        function extractPlayerGold() {
            // Look for "You have X gold pieces."
            const match = recentTerminalText.match(/You have (\d+) gold piece/i);
            
            if (match) {
                playerGold = parseInt(match[1]);
                console.log('Player gold:', playerGold);
                waitingForGoldCheck = false;
                
                // Now look at shopkeeper to get shop items
                if (currentShopkeeper) {
                    waitingForShopItems = true;
                    sendCommand('look ' + currentShopkeeper);
                }
            }
        }

        function showShopItemsWithPrices() {
            const overlay = document.getElementById('popupOverlay');
            const titleEl = document.getElementById('popupTitle');
            const listEl = document.getElementById('popupButtonList');
            
            // Create header showing player gold
            titleEl.innerHTML = `Buy Items - Gold: <span style="color: gold">${playerGold}</span>`;
            
            listEl.innerHTML = '';
            
            currentShopItems.forEach(item => {
                const canAfford = playerGold >= item.price;
                const btn = document.createElement('button');
                btn.className = 'popup-list-btn';
                btn.style.display = 'flex';
                btn.style.justifyContent = 'space-between';
                btn.style.alignItems = 'center';
                
                // Create name span
                const nameSpan = document.createElement('span');
                nameSpan.textContent = item.name;
                if (!canAfford) {
                    nameSpan.style.color = '#ff4444'; // Red for unaffordable
                }
                
                // Create price span
                const priceSpan = document.createElement('span');
                priceSpan.textContent = item.price + 'g';
                priceSpan.style.color = 'gold';
                priceSpan.style.marginLeft = '16px';
                
                btn.appendChild(nameSpan);
                btn.appendChild(priceSpan);
                
                if (canAfford) {
                    btn.onclick = () => {
                        sendCommand('buy ' + item.name);
                        closePopup();
                    };
                } else {
                    btn.style.opacity = '0.5';
                    btn.style.cursor = 'not-allowed';
                }
                
                listEl.appendChild(btn);
            });
            
            overlay.classList.add('active');
        }

        function extractShopItems() {
            // Look for shop inventory format: "Qty  Price  <item>"
            // Qty can be a number OR a period (.) for services
            const lines = recentTerminalText.split('\n');
            const items = [];
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                // Match lines with (number or period) for qty, then price (number), then item name
                // Format: "   .   100    CURE - description" or "  65   15     pink potion"
                const match = line.match(/^[.\d]+\s+(\d+)\s+(.+)$/);
                if (match) {
                    const itemName = match[2].trim();
                    // Only take the item name before any dash or extra description
                    const cleanName = itemName.split(/\s+-\s+/)[0].trim();
                    items.push({
                        name: cleanName,
                        price: parseInt(match[1])
                    });
                }
            }
            
            if (items.length > 0) {
                waitingForShopItems = false;
                currentShopItems = items;
                // Gold check already done, show items
                showShopItemsWithPrices();
            }
        }

        function extractInventoryForShop() {
            // Look for "You are holding" - use lastIndexOf to find the most recent occurrence
            const searchText = 'You are holding';
            const lastIndex = recentTerminalText.lastIndexOf(searchText);
            
            if (lastIndex !== -1) {
                // Extract text after "You are holding"
                const afterText = recentTerminalText.substring(lastIndex + searchText.length);
                
                // Take until period (including newlines)
                const match = afterText.match(/^([\s\S]+?)\./);
                
                if (match) {
                    const itemString = match[1];
                    
                    // Split by commas and "and", then clean up
                    const items = itemString
                        .replace(/\s+and\s+/gi, ',') // Replace "and" with comma
                        .split(/[,]/)
                        .map(item => item.trim())
                        .map(item => item.replace(/^(a |an )/i, '')) // Remove "a" or "an" prefix
                        .map(item => item.replace(/^suit of /i, '')) // Remove "suit of" prefix
                        .filter(item => item.length > 0)
                        .filter(item => !['a', 'an'].includes(item.toLowerCase())); // Filter out standalone "a" or "an"
                    
                    if (items.length > 0) {
                        if (waitingForSellItems) {
                            waitingForSellItems = false;
                            showShopItemButtons(items, 'sell');
                        } else if (waitingForAppraiseItems) {
                            waitingForAppraiseItems = false;
                            showShopItemButtons(items, 'appraise');
                        }
                    }
                }
            }
        }

        function extractInventoryForEquip() {
            // Look for "You are holding" - use lastIndexOf to find the most recent occurrence
            const searchText = 'You are holding';
            const lastIndex = recentTerminalText.lastIndexOf(searchText);
            
            console.log('Equip: Looking for inventory, lastIndex:', lastIndex);
            console.log('Equip: Recent text length:', recentTerminalText.length);
            
            if (lastIndex !== -1) {
                // Extract text after "You are holding"
                const afterText = recentTerminalText.substring(lastIndex + searchText.length);
                
                // Take until period (including newlines)
                const match = afterText.match(/^([\s\S]+?)\./);
                
                if (match) {
                    const itemString = match[1];
                    console.log('Equip: Raw item string:', itemString);
                    
                    // Split by commas and "and", then clean up
                    const items = itemString
                        .replace(/\s+and\s+/gi, ',') // Replace "and" with comma
                        .split(/[,]/)
                        .map(item => item.trim())
                        .map(item => item.replace(/^(a |an )/i, '')) // Remove "a" or "an" prefix
                        .map(item => item.replace(/^suit of /i, '')) // Remove "suit of" prefix
                        .filter(item => item.length > 0)
                        .filter(item => !['a', 'an'].includes(item.toLowerCase())); // Filter out standalone "a" or "an"
                    
                    console.log('Equip: Parsed items:', items);
                    
                    if (items.length > 0) {
                        if (waitingForArmItems) {
                            waitingForArmItems = false;
                            showEquipItemButtons(items, 'arm');
                        } else if (waitingForWearItems) {
                            waitingForWearItems = false;
                            showEquipItemButtons(items, 'wear');
                        }
                    }
                }
            }
        }

        function showEquipItemButtons(items, action) {
            const title = action === 'arm' ? 'Arm Item' : 'Wear Item';
            showPopup(title, items, (item) => {
                sendCommand(action + ' ' + item);
            });
        }

        function showShopItemButtons(items, action) {
            const title = action === 'buy' ? 'Buy Item' : action === 'sell' ? 'Sell Item' : 'Appraise Item';
            showPopup(title, items, (item) => {
                sendCommand(action + ' ' + item);
            });
        }

        function checkForSpellRefresh() {
            // Look for "Cast WHAT spell?" to trigger spell refresh
            if (recentTerminalText.includes('Cast WHAT spell?')) {
                waitingForSpellRefresh = false;
                currentSpells = []; // Clear old spells
                waitingForSpells = true;
                sendCommand('spells');
            }
        }

        function checkForItemDrops(text) {
            // Look for pattern: "<item> falls to the ground!"
            const regex = /(.+?)\s+falls to the ground!/gi;
            const matches = [...text.matchAll(regex)];
            
            if (matches.length > 0) {
                // Get the last match (most recent drop)
                const lastMatch = matches[matches.length - 1];
                let item = lastMatch[1].trim();
                
                // Remove "a" or "an" prefix
                item = item.replace(/^(a |an )/i, '');
                
                console.log('Item dropped:', item);
                
                // Auto-get the item
                setTimeout(() => {
                    sendCommand('get ' + item);
                }, 100);
            }
            
            // Check for spell level up
            if (text.includes('The god smiles at you in approval')) {
                console.log('Spell level up detected!');
                // Refresh spell list
                currentSpells = [];
                waitingForSpells = true;
                setTimeout(() => {
                    sendCommand('spells');
                }, 100);
            }
        }

        function extractPotions() {
            // Look for "You are holding" - use lastIndexOf to find the most recent occurrence
            const searchText = 'You are holding';
            const lastIndex = recentTerminalText.lastIndexOf(searchText);
            
            if (lastIndex !== -1) {
                // Extract text after "You are holding"
                const afterText = recentTerminalText.substring(lastIndex + searchText.length);
                
                // Take until period (including newlines)
                const match = afterText.match(/^([\s\S]+?)\./);
                
                if (match) {
                    const itemString = match[1];
                    console.log('Inventory string found:', itemString);
                    
                    // Split by commas and "and", then clean up
                    const items = itemString
                        .replace(/\s+and\s+/gi, ',') // Replace "and" with comma
                        .split(/[,]/)
                        .map(item => item.trim())
                        .map(item => item.replace(/^(a |an )/i, '')) // Remove "a" or "an" prefix
                        .map(item => item.replace(/^suit of /i, '')) // Remove "suit of" prefix
                        .filter(item => item.length > 0);
                    
                    // Filter only items ending with "potion"
                    const potions = items.filter(item => {
                        const lower = item.toLowerCase();
                        return lower.endsWith('potion') || lower.includes('potion');
                    });
                    
                    waitingForPotions = false;
                    console.log('Potions found:', potions);
                    
                    if (potions.length > 0) {
                        currentPotions = potions;
                        showPopup('Select Potion', potions, (potion) => {
                            sendCommand('drink ' + potion);
                            setTimeout(() => sendCommand('hits'), 100);
                        });
                    } else {
                        // No potions, just send DRINK
                        currentPotions = [];
                        sendCommand('drink');
                    }
                }
            }
        }

        function extractExits() {
            // Look for "Visible exits are:" - use lastIndexOf to find the most recent occurrence
            const searchText = 'Visible exits are:';
            const lastIndex = recentTerminalText.lastIndexOf(searchText);
            
            if (lastIndex !== -1) {
                // Extract text after "Visible exits are:"
                const afterText = recentTerminalText.substring(lastIndex + searchText.length);
                
                // Take until period (including newlines)
                const match = afterText.match(/^([^\n.]+)/);
                
                if (match) {
                    const exitString = match[1];
                    console.log('Exit string found:', exitString);
                    
                    // Split by commas and remove "and"
                    const exits = exitString
                        .toLowerCase()
                        .replace(/\band\b/g, '')
                        .split(/[,\s]+/)
                        .map(e => e.trim())
                        .filter(e => e.length > 0 && e !== '');
                    
                    waitingForExits = false;
                    console.log('Exits parsed:', exits);
                    updateNavButtons(exits);
                }
            }
        }

        function updateNavButtons(availableExits) {
            // Disable all nav buttons first
            const navButtons = ['btnN', 'btnS', 'btnE', 'btnW', 'btnU', 'btnD'];
            const directionMap = {
                'n': 'btnN', 'north': 'btnN',
                's': 'btnS', 'south': 'btnS',
                'e': 'btnE', 'east': 'btnE',
                'w': 'btnW', 'west': 'btnW',
                'u': 'btnU', 'up': 'btnU',
                'd': 'btnD', 'down': 'btnD'
            };
            
            // Disable all buttons
            navButtons.forEach(btnId => {
                const btn = document.getElementById(btnId);
                if (btn) btn.disabled = true;
            });
            
            // Enable only available exits
            availableExits.forEach(exit => {
                const btnId = directionMap[exit];
                if (btnId) {
                    const btn = document.getElementById(btnId);
                    if (btn) btn.disabled = false;
                }
            });
        }

        function enableAllNavButtons() {
            const navButtons = ['btnN', 'btnS', 'btnE', 'btnW', 'btnU', 'btnD'];
            navButtons.forEach(btnId => {
                const btn = document.getElementById(btnId);
                if (btn) btn.disabled = false;
            });
        }

        function updateTargets() {
            const targets = extractTargets(recentTerminalText);
            
            if (targets.length > 0) {
                currentTargets = targets;
                console.log('Targets found:', targets);
            }
        }

        function handleHitButton() {
            // Send LOOK to get fresh target list
            waitingForTargetDetection = true;
            targetDetectionForSpell = false;
            sendCommand('look');
        }

        function handleCastButton() {
            if (currentSpells.length > 0) {
                // Send LOOK to get fresh target list before showing spell selection
                waitingForTargetDetection = true;
                targetDetectionForSpell = true;
                sendCommand('look');
            } else {
                waitingForSpells = true;
                sendCommand('spells');
            }
        }

        function handleDrinkButton() {
            waitingForPotions = true;
            sendCommand('i');
        }

        function handleHelpButton() {
            const topics = [
                'Air', 'Attributes', 'Combat', 'Commands', 'Credits',
                'Earth', 'Elements', 'Experience', 'Fire', 'Gold',
                'Hints', 'Invoking', 'Items', 'Magic', 'Movement',
                'Speed', 'Starting', 'Talismans', 'Water'
            ];
            showPopup('Help Topics', topics, (topic) => {
                sendCommand('help ' + topic);
            });
        }

        function handleSocialButton() {
            const actions = [
                'Bow', 'Blush', 'Burp', 'Chortle', 'Cry', 'Frown',
                'Glare', 'Grin', 'Grumble', 'Hug', 'Kick', 'Kiss',
                'Laugh', 'Nod', 'Smack', 'Smile', 'Smooch', 'Snarl', 'Wave'
            ];
            showPopup('Social Actions', actions, (action) => {
                sendCommand(action);
            });
        }

        function handleShopButton() {
            // Send LOOK command to refresh room info
            waitingForShopDetection = true;
            sendCommand('look');
        }

        function handleEquipButton() {
            const actions = ['Arm', 'Disarm', 'Wear', 'Disrobe'];
            showPopup('Equip', actions, (action) => {
                handleEquipAction(action);
            });
        }

        function handleMapButton() {
            // Clear recent text buffer to ensure we only capture the fresh LOOK
            recentTerminalText = '';
            // Send LOOK and wait for map data
            waitingForMapLook = true;
            sendCommand('look');
        }

        function handleSettingsButton() {
            showSettingsPopup();
        }

        function showSettingsPopup() {
            const overlay = document.getElementById('popupOverlay');
            const titleEl = document.getElementById('popupTitle');
            const listEl = document.getElementById('popupButtonList');
            
            titleEl.textContent = 'Settings';
            
            listEl.innerHTML = `
                <div class="settings-group">
                    <span class="settings-label">Descriptions</span>
                    <div class="settings-toggle">
                        <button id="descShort" onclick="setDescriptionMode('short')" ${descriptionMode === 'short' ? 'class="active"' : ''}>Short</button>
                        <button id="descLong" onclick="setDescriptionMode('long')" ${descriptionMode === 'long' ? 'class="active"' : ''}>Long</button>
                    </div>
                </div>
                
                <div class="settings-group">
                    <span class="settings-label">Terminal Font Size</span>
                    <div class="font-size-controls">
                        <button class="font-size-btn" onclick="decreaseFontSize()">‚è¨</button>
                        <div class="font-size-display" id="fontSizeDisplay">${terminalFontSize.toFixed(1)}em</div>
                        <button class="font-size-btn" onclick="increaseFontSize()">‚è´</button>
                    </div>
                </div>
                
                <div class="settings-group" style="margin-top: 20px; border-top: 1px solid var(--border-default); padding-top: 20px;">
                    <button class="popup-list-btn" onclick="handleLogoff()" style="background: var(--accent-danger); color: white; text-align: center;">
                        Logoff
                    </button>
                </div>
            `;
            
            overlay.classList.add('active');
        }

        function setDescriptionMode(mode) {
            descriptionMode = mode;
            localStorage.setItem('bbs_description_mode', mode);
            
            // Update button states
            document.getElementById('descShort').classList.toggle('active', mode === 'short');
            document.getElementById('descLong').classList.toggle('active', mode === 'long');
            
            // Send command
            if (mode === 'short') {
                sendCommand('brief');
            } else {
                sendCommand('verbose');
            }
        }

        function increaseFontSize() {
            if (terminalFontSize < 2.0) {
                terminalFontSize += 0.1;
                applyFontSize();
            }
        }

        function decreaseFontSize() {
            if (terminalFontSize > 0.5) {
                terminalFontSize -= 0.1;
                applyFontSize();
            }
        }

        function applyFontSize() {
            const terminal = document.getElementById('terminal');
            terminal.style.fontSize = terminalFontSize + 'em';
            document.getElementById('fontSizeDisplay').textContent = terminalFontSize.toFixed(1) + 'em';
            localStorage.setItem('bbs_terminal_font_size', terminalFontSize);
        }

        function handleLogoff() {
            // Close the settings popup
            closePopup();
            // Send logoff command
            sendCommand('=x');
            // Reload page after brief delay
            setTimeout(() => {
                location.reload();
            }, 500);
        }

        function loadSettings() {
            // Load saved settings
            const savedFontSize = localStorage.getItem('bbs_terminal_font_size');
            if (savedFontSize) {
                terminalFontSize = parseFloat(savedFontSize);
                const terminal = document.getElementById('terminal');
                terminal.style.fontSize = terminalFontSize + 'em';
            }
            
            const savedDescMode = localStorage.getItem('bbs_description_mode');
            if (savedDescMode) {
                descriptionMode = savedDescMode;
            }
        }

        function showMapPopup(imagePath) {
            const overlay = document.getElementById('popupOverlay');
            const titleEl = document.getElementById('popupTitle');
            const listEl = document.getElementById('popupButtonList');
            
            titleEl.textContent = 'Town Map';
            
            // Create image container with zoom capability
            listEl.innerHTML = `
                <div class="map-image-container">
                    <img src="${imagePath}" alt="Town Map" class="map-image" id="mapImage" onclick="toggleMapZoom()">
                </div>
            `;
            
            overlay.classList.add('active');
        }

        function toggleMapZoom() {
            const img = document.getElementById('mapImage');
            if (img) {
                img.classList.toggle('zoomed');
            }
        }

        async function detectAndShowMap() {
            waitingForMapLook = false;
            
            // Load map data if not cached
            if (!mapData) {
                try {
                    const response = await fetch('Rooms_With_Clusters.json');
                    mapData = await response.json();
                } catch (e) {
                    console.error('Failed to load map data:', e);
                    alert('Map data file not found. Please ensure Rooms_With_Clusters.json is in the same directory.');
                    return;
                }
            }
            
            // Find the most recent LOOK output by finding last line starting with "..."
            const lastDotIndex = recentTerminalText.lastIndexOf('\n...');
            if (lastDotIndex === -1) {
                // Try without newline (might be at start of buffer)
                const startDotIndex = recentTerminalText.indexOf('...');
                if (startDotIndex === -1) {
                    console.log('No room description found (no "..." line)');
                    return;
                }
                var lookOutput = recentTerminalText.substring(startDotIndex);
            } else {
                var lookOutput = recentTerminalText.substring(lastDotIndex + 1); // +1 to skip the \n
            }
            
            // Skip the first line (short description) - just find the first newline
            const firstNewline = lookOutput.indexOf('\n');
            if (firstNewline === -1) {
                console.log('No long description found (no lines after short desc)');
                return;
            }
            
            // Get text after the first line (skip short description)
            const afterShort = lookOutput.substring(firstNewline + 1);
            
            // Extract long description (everything until prompt ")" or end)
            const lines = afterShort.split('\n');
            let longDesc = '';
            
            for (const line of lines) {
                const trimmed = line.trim();
                // Stop at prompt
                if (trimmed === ')') break;
                // Accumulate non-empty lines
                if (trimmed) {
                    if (longDesc) longDesc += ' ';
                    longDesc += trimmed;
                }
            }
            
            if (!longDesc) {
                console.log('No long description extracted');
                return;
            }
            
            // Normalize: remove ALL whitespace for comparison
            const normalizedBBS = longDesc.replace(/\s+/g, '');
            
            console.log('Looking for room (first 1024 chars):', longDesc.substring(0, 1024));
            console.log('Normalized BBS (first 1024):', normalizedBBS.substring(0, 1024));
            
            // Search all rooms - BBS output STARTS WITH room.long (room.long may be shorter)
            let foundRoomId = null;
            for (const [roomId, room] of Object.entries(mapData.rooms)) {
                // Normalize room long desc: remove all whitespace
                const normalizedRoom = room.long.replace(/\s+/g, '');
                
                // BBS output includes room desc + items/NPCs/players
                // So: normalizedBBS.startsWith(normalizedRoom)
                if (normalizedBBS.startsWith(normalizedRoom) || normalizedRoom.startsWith(normalizedBBS)) {
                    foundRoomId = roomId;
                    console.log('Matched room:', roomId, 'short:', room.short);
                    break;
                }
            }
            
            if (!foundRoomId) {
                console.log('Room not found in map data');
                console.log('Searched for (normalized, first 1024):', normalizedBBS.substring(0, 1024));
                alert('Current room not found in map database');
                return;
            }
            
            // Show interactive map centered on this room
            showInteractiveMap(foundRoomId);
        }

        function showInteractiveMap(centerRoomId) {
            const room = mapData.rooms[centerRoomId];
            if (!room) return;
            
            const overlay = document.getElementById('mapPopupOverlay');
            const contentEl = document.getElementById('mapPopupContent');
            
            // Map_full_grid.html already handles ?roomId parameter
            contentEl.innerHTML = `
                <iframe 
                    id="mapIframe" 
                    src="Map_full_grid.html?roomId=${centerRoomId}" 
                    style="width: 100%; height: 100%; border: none; background: #121212;">
                </iframe>
            `;
            
            overlay.classList.add('active');
        }

        function closeMapPopup(event) {
            if (event && event.target.id !== 'mapPopupOverlay' && event.type === 'click') {
                // Clicked inside popup, not the overlay
                return;
            }
            const overlay = document.getElementById('mapPopupOverlay');
            overlay.classList.remove('active');
        }


        function handleEquipAction(action) {
            if (action === 'Arm') {
                // Always refresh inventory before showing items
                waitingForArmItems = true;
                sendCommand('i');
            } else if (action === 'Disarm') {
                sendCommand('disarm');
            } else if (action === 'Wear') {
                // Always refresh inventory before showing items
                waitingForWearItems = true;
                sendCommand('i');
            } else if (action === 'Disrobe') {
                sendCommand('disrobe');
            }
        }

        function sendCurrentInput() {
            const input = document.getElementById('commandInput');
            const command = input.value.trim();
            
            if (command) {
                sendCommand(command);
                input.value = '';
            } else {
                // Send just ENTER if input is empty
                sendCommand('');
            }
            input.focus();
        }

        function handleEnter(event) {
            if (event.key === 'Enter') {
                sendCurrentInput();
            }
        }
    </script>
</body>
</html>
